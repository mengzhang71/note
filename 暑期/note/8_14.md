## 任务：

用二维码扫出这个页面来，在网上找一个截取url的id的逻辑方法，

这里写样式，所以的数据都是通过接口（传url）过来的，把数据绑上去



# Vue3

[[Vue\]Vue3学习笔记(尚硅谷)_vue3尚硅谷笔记_萤火虫的小尾巴的博客-CSDN博客](https://blog.csdn.net/m0_53022813/article/details/128527334?ops_request_misc=%7B%22request%5Fid%22%3A%22169199762716800185884007%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=169199762716800185884007&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-128527334-null-null.142^v92^control&utm_term=Vue3尚硅谷&spm=1018.2226.3001.4187)

### 项目结构

对比

![image-20230814114515436](8.14.assets/image-20230814114515436.png)





可以没有根标签了







### reactive函数

ref处理对象类型时，会求助reative  （此次对象的.value就是proxy、reavtive创建的吧？）

整个都变成响应式了，深层次的



原理和ref不一样

- ref通过`Object.defineProperty()`的`get`与`set`来实现响应式（数据劫持）。
- reactive通过使用**Proxy**来实现响应式（数据劫持）, 并通过**Reflect**操作**源对象**内部的数据

代理后，可以对数组可以直接赋值了

比起ref，不用写value了



一般来说，都把组件用到的数据都封装到一个对象里，所以reactive常用

### vue2响应式

使用Object.defineProperty()的get（）、set（）对读取、修改进行数据劫持

无法新增、删除，

**解决方法**：只能使用this.$set、$delete，

直接通过下标修改数组，页面不更新

**解决方法:**this.$set(数组，index，value)，用数组方法





### vue3响应式

target ：源对象

通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。但没有像我们那么low，直接在proxy里直接修改数据而是，

通过Reflect（反射）: 对源对象的属性进行操作。



Object.defineProperty重复修改同一个属性会报错（只能通过try...catch；了），而Reflect.defineProperty会通过返回布尔值提醒--代码健壮性



完整步骤：

```
//模拟Vue3中实现响应式
//#region 
const p = new Proxy(person,{
	//有人读取p的某个属性时调用
	get(target,propName){
		console.log(`有人读取了p身上的${propName}属性`)
		return Reflect.get(target,propName)
	},
	//有人修改p的某个属性、或给p追加某个属性时调用
	set(target,propName,value){
		console.log(`有人修改了p身上的${propName}属性，我要去更新界面了！`)
		Reflect.set(target,propName,value)
	},
	//有人删除p的某个属性时调用
	deleteProperty(target,propName){
		console.log(`有人删除了p身上的${propName}属性，我要去更新界面了！`)
		return Reflect.deleteProperty(target,propName)
	}
})
//#endregion


```



### set up函数注意点

#### 执行时机



#### 两个传入值：props、context

props且是proxy（是不是说明和vue2只能用不能修改不一样了？）

有东西传入但没用prop接收会警告    那$attr还会生效吗



context里有attr、emit、slot、



emits:['hello'], *// 绑定的自定义事件在组件中需要使用emits配置项接收*





### watch

从配置项变成函数了（去看看注解@watch）



监测的是结构，第一个参数怎么都不加value

三个参数





reatvie没 oldvalue、deep了	（ref还是都能用）

如果真的需要oldvalue，把数据拎出去用ref处理





当监测的是reative定义的对象的某个属性，

第一个参数写成函数回调：()=>person.job

deep有效（不过只有对象属性才配用）



### 生命周期

销毁名字变成卸载了

v-if 里面写组件```<Demo v-if="isShowDemo"/>``` 不生效的时候就被卸载

对组合api的理解：钩子函数也能从配置项变成组合api，可以放入组合api的大舞台--setup（）				更加的高内聚，低耦合

但每一个都得改名



使用：先import引入



### 自定义hook函数

数据、方法、生命周期（把setup中使用的组合api进行封装）

完全放到一个函数里



像个工具包，说和mixin很像（去看看mixin）





### toRef和toRefs

不丢响应式的传出去

toRef  像$set一样的用法样的

*const name2 = toRef(person,'name')*





toRefs还是浅的，只把一层都变成了proxy





### 其他组合api

#### shallowRef

不求人的ref

#### shallowReactive 

只处理对象最外层属性的响应式（浅响应式）





- 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生成新的对象来替换，即对于该对象数据在后续功能中不会修改其属性，而是会将该对象整个进行替换 ===> shallowRef。

  

  使它能够查看到、但不能修改无效，但是又要当它整个被替换时能被监测到



#### readonly 和shallowReadonly 

接收一个响应式数据为参数。

readonly 深只读

shallowReadonly 马奇诺只读



### toRaw 与 markRaw

- toRaw 接收一个响应式对象为参数，只能接收reactive生成的响应式对象，不能处理ref生成的响应式数据
- 作用：将一个由`reactive`生成的**响应式对象**转为**普通对象**。



那我直接等于赋值效果不是一样吗？

直接深拷贝不就行了？还要这个干嘛？（应该是深拷贝对proxy对象有什么限制吧？）

弹幕说提交表单的时候要用



markRaw：
接收一个对象类型数据为参数
作用：标记一个对象，使其永远不会再成为响应式对象。向一个已经是响应式对象的数据追加一个属性，该属性的值为对象类型数据，vue会为其自动添加响应式，当不希望该属性的值为响应式时可以使用该函数，减小开销。
应用场景:
有些值不应被设置为响应式的，例如复杂的第三方类库等，如果向响应式对象追加一个第三方类库对象(一般属性多且层次多)，开销会很大。
当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。



### customRef

毛坯房ref，手动挡ref

没看懂track,trigger操作，去找点东西看

### provide 与 inject

provide 与 inject

### 响应式数据的判断

isRef: 检查一个值是否为一个 ref 对象
isReactive: 检查一个对象是否是由 reactive 创建的响应式代理
isReadonly: 检查一个对象是否是由 readonly 创建的只读代理
isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理





### Teleport

Teleport

将我们的**组件html结构**移动到指定位置

加个遮罩，to='body',实现弹窗







# 小程序



## 宿主环境-组件

### 视图容器

![image-20230816150352331](8_14.assets/image-20230816150352331.png)

#### **view使用**  

普通div，照样用css的东西（标签里用.class,选择器）

![image-20230816150420036](8_14.assets/image-20230816150420036.png)







#### 使用scroll-view  标签

1.标签加纵向滚向属性，

2.纵向滚动的话，就给这个容器固定高度

![image-20230816150734798](8_14.assets/image-20230816150734798.png)

****

#### 轮播图容器

![image-20230816151138494](8_14.assets/image-20230816151138494.png)

![image-20230816151237301](8_14.assets/image-20230816151237301.png)

1.

![image-20230816151503392](8_14.assets/image-20230816151503392.png)





---



![image-20230816151444214](8_14.assets/image-20230816151444214.png)

---

小圆点的激活颜色和未激活颜色



### 基础内容

#### 常用的

![image-20230816152534820](8_14.assets/image-20230816152534820.png)



##### 使用:

![image-20230816152730758](8_14.assets/image-20230816152730758.png)



---

![image-20230816152805147](8_14.assets/image-20230816152805147.png)





#### 其他

![image-20230816152946460](8_14.assets/image-20230816152946460.png)

type:主色调

size

plain:没有背景色,但有边框线

![image-20230816153027962](8_14.assets/image-20230816153027962.png)





样式版本,去掉它页面样式会有很大变化

![image-20230816153310860](8_14.assets/image-20230816153310860.png)

![image-20230816153400573](8_14.assets/image-20230816153400573.png)

---



##### image

![image-20230816152956757](8_14.assets/image-20230816152956757.png)

###### 使用:

![image-20230816153430158](8_14.assets/image-20230816153430158.png)

---

###### 属性:

![image-20230816153451563](8_14.assets/image-20230816153451563.png)

aspectFit:副作用,会有留白



---



![image-20230816153004710](8_14.assets/image-20230816153004710.png)

### 表单最优解



### 导航组件



媒体组件



## 宿主环境-api

![image-20230816154045552](8_14.assets/image-20230816154045552.png)



没理解同步api的执行结果,可以通过函数返回值直接获取是什么意思



## 协同工作和发布

### 小程序成员管理

![image-20230816154539943](8_14.assets/image-20230816154539943.png)

![image-20230816154735282](8_14.assets/image-20230816154735282.png)

添加项目成员和体验成员





### 发布

#### 上传

![image-20230816154925542](8_14.assets/image-20230816154925542.png)



审核完就可以点击发布上线了



#### 推广

两个码都可以



设置->基本设置

名称、码etc...

![image-20230816155245656](8_14.assets/image-20230816155245656.png)



#### 运营数据

后台的统计







看前思考：

​	WXML

​	wxss是啥，不是直接用css吗

.json的使用

网络请求

## WXML模块语法

### 数据绑定

#### **在data中定义数据**

和vue一样，data是个大对象

![image-20230816160003449](8_14.assets/image-20230816160003449.png)

#### 在WXML中使用数据

Mustache语法（插值语法）

![image-20230816160200247](8_14.assets/image-20230816160200247.png)

##### 应用场景

 **动态绑定内容**

如上

**动态绑定属性**

和vue的需要用v-bind指令不一样，也和内容一样直接用就行

![image-20230816160547616](8_14.assets/image-20230816160547616.png)



**计算：**

**三元运算符**

 ![image-20230816160652865](8_14.assets/image-20230816160652865.png)

**算数运算**



### 事件绑定

把渲染层产生的变化传到逻辑层

![image-20230816161025724](8_14.assets/image-20230816161025724.png)

#### 常用事件

![image-20230816161122675](8_14.assets/image-20230816161122675.png)

### **bindtap**及事件的一些基本东西

![image-20230816162237996](8_14.assets/image-20230816162237996.png)

---

打印的这个 e 里面的属性就是下面的

![image-20230816162342604](8_14.assets/image-20230816162342604.png)



---

event.traget

![image-20230816161818915](8_14.assets/image-20230816161818915.png)



#### 事件处理函数中给data的数据赋值

划重点：通过什么方法修改的；新值和旧值是怎么表达的

![image-20230816162718680](8_14.assets/image-20230816162718680.png)



#### 事件传参（和vue不一样）

什么东西都放在e里

![image-20230816162943548](8_14.assets/image-20230816162943548.png)

---

**放：**

data-

![image-20230816163010527](8_14.assets/image-20230816163010527.png)

传参可以传data的数据吗，那怎么区分string和变量的？

不加{{}}，就是字符串的2，传数字用{{}}

**拿：**

![image-20230816163343273](8_14.assets/image-20230816163343273.png)

**使用：**

![image-20230816163804056](8_14.assets/image-20230816163804056.png)



### bindinput

![image-20230816164219826](8_14.assets/image-20230816164219826.png)

#### 文本框和data数据的同步

![image-20230816164443185](8_14.assets/image-20230816164443185.png)

![image-20230816164502279](8_14.assets/image-20230816164502279.png)

![image-20230816164608168](8_14.assets/image-20230816164608168.png)

![image-20230816164538036](8_14.assets/image-20230816164538036.png)

### 条件渲染

![image-20230816165102494](8_14.assets/image-20230816165102494.png)



blok,只起包裹作用



也可以用hidden直接控制标签显示和隐藏（就是更改display。有vue那味了欧，视频也有对比）

![image-20230816165814097](8_14.assets/image-20230816165814097.png)



![image-20230816170034335](8_14.assets/image-20230816170034335.png)



### 列表渲染 wx:for

默认自带index和item

![image-20230816170553494](8_14.assets/image-20230816170553494.png)

**手动指定**

![image-20230816170815903](8_14.assets/image-20230816170815903.png)

---



**wx:key**

这个key也能像vue一样，是这么用吗，wx:key = "{{index}}"（要不要加引号）

![image-20230816170905271](8_14.assets/image-20230816170905271.png)



## WXSS模块样式

WXSs(WeiXin Style Sheets)是一套样式语言，用于美化 WXML的组件样式，类似于网页开发中的 CSS.



WXSS 具有 CSS 大部分特性，同时，WXSS 还对 CSS 进行了扩充以及修改，以适应微信小程序的开发与CSS相比，wXS 扩展的特性有:
rpx 尺寸单位
@import 样式导入



不能用rem了，就用rpx

![image-20230816171234796](8_14.assets/image-20230816171234796.png)



#### rpx尺寸单位

rpx (responsive pixel) 是微信小程序独有的，用来解决屏适配的尺寸单位



**rpx的实现原理**
rpx 的实现原理非常简单:鉴于不同设备屏幕的大小不同，为了实现屏幕的自动适配，rpx 把所有设备的屏幕在宽度上等分为 750 份 (即: 当前屏幕的总宽度为 750rpx)。

---



官方建议: 开发微信小程序时，设计师可以用 iphone6 作为视觉稿的标准

开发举例:在iPhone6上如果要绘制宽100px，高20px的盒子，换算成rpx单位，宽高分别为 200rpx和 40rpx.



#### 样式导入 @import

**语法格式**
@import 后跟需要导入的外联样式表的相对路径，用;表示语句结束。示例如下

![image-20230816171653384](8_14.assets/image-20230816171653384.png)



全局样式和局部样式

app.wxss







## json的那个配置

### 全局app.json

小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下

**window**
全局设置小程序窗口的外观

pages
记录当前小程序所有页面的存放路径

**tabBar**
设置小程序底部的 tabBar 效果
style
是否启用新版的组件样式



#### 小程序窗口的组成部分

![image-20230816172157916](8_14.assets/image-20230816172157916.png)

window就是前两个个 主要就是做导航栏区域的

## window

### 常用配置项

![image-20230816172413355](8_14.assets/image-20230816172413355.png)

标题颜色（navigationBarTextStyle）只能设置black和white



下拉刷新开启，就能看到背景了，真机上下拉刷新后并不会合上，还要进行相应处理

#### 设置导航栏标题

设置步骤: app.json -> window -> navigationBarTitleText

需求:把导航条上的标题，从默认的“WeChat”修改为“黑马程序员”效果如图所示:

![image-20230816172522817](8_14.assets/image-20230816172522817.png)



![image-20230816172624328](8_14.assets/image-20230816172624328.png)

## 页面page.json



## 网络数据请求