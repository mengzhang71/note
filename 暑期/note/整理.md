# 项目

## 查询页面

写api有三部曲

#### 查询、重置按钮逻辑

handleResetQuery事件

把搜索框的内容清空

深克隆咱们的const变量

重新赋searchParams--解构，其他照搬，只有userAuditStatus重赋，是query

就为空，其他就不管

最后请求 this.fetchDeclareSearchPage()

最后请求数据fetch.post('/xiangmu/declareSearch/page', this.searchParams



**这里顺着引申下的获取数据**

表单数据和下拉栏的数据是获取是不一样的（后者是要送进elementUI的对数据格式要求很高），下拉栏的数据需要接过来先做处理，label、value、children



### Managent页面：

#### v-bind=“$attrs、v-on="$listeners"部分

##### v-bind="$attrs"

主要用于组件之间的隔代传值，**高层级向底层级传值**

A组件中的值需要直接传给C，那么就需要在B中设置v-bind="$attrs"，然后在C组件中用prop接收，此时就直接把值传给了C组件。

##### v-on="$listeners"

主要用于底层组件向高层组件传递信息

我的理解，在这里是二次封装el-table 时用到了，

封装el-table里的	<el-table-column时，el-table 里

我知道它是跨级通信用到的，但是它到底是怎么用的呢



managent页面：

![image-20230630104058265](%E6%95%B4%E7%90%86.assets/image-20230630104058265.png)

headers里面加了想要加这样的样式的，一定要加component，后面会提到用到了table-col自带插槽里



Grid里的 :total="total"，就是通过v-bind=“$attrs传给子了的，没人用prop接收



```
      <html-content
        v-else-if="col.component"
        v-bind="$attrs"
        v-on="$listeners"
        :html="col.component(scope.row, index)"
        :row="scope.row"
        :index="index"
      ></html-content>
```

DynamicColumn组件下自己写了htmlContent组件

```
   htmlContent: {
      props: {
        html: String,
        row: Object,
        index: Number
      },
      render (h: any) {
        const self: Vue = this
        const component = Vue.extend({
          template: `<div @click.stop="onComponentClick">${self.$props.html}</div>`,
          methods: {
            onComponentClick () {
              this.$children.forEach((item: any) => {
                self.$emit(item.$attrs.clickName, self.$props.row, self.$props.index)
              })
            }
          }
        })

        return h(component, {
          // on: {
          //   click: function() {
          //     console.log(111)
          //     ;(self as any).aaa()
          //   }
          // }
        })
      }
    }
```

   template: `<div @click.stop="onComponentClick">${self.$props.html}</div>`,

这里的${self.$props.html}

外面

 :html="col.component(scope.row, index)"

col是sortHeaders里的遍历的item

喏，就是这里component

![image-20230630104058265](%E6%95%B4%E7%90%86.assets/image-20230630104058265.png)



​      this.$children.forEach((item: any) => {

荣哥说，外面一定要用component的原因，要不然这里遍历的就是空元素了（没有children）$children是指这个下面的整个组件，不是元素啥的



 如果heade里的component如果有点击方法，就执行咯，(还是问一问吧)









## Grid（含studentInfo）

**grid里的动态栏**

col是i从grid里传进来的item



#### DynamicColumn组件

封装的el-table



 数据  :data="items"通过 v-bind="$attrs"也传进DynamicColumn组件了



DynamicColumn组件传进去的数据 :col="item"

item 就是sortHeaders   v-for="(item, index) in sortHeaders"

DynamicColumn组件就开始根据col渲染表头、表格

  :label="col.text"

  :prop="col.value"

label是表头，prop是表格



#### 日期处理

```js
{{ dateFormatter(scope.row[scope.column.property], col.dateType) }} 

dateFormatter(time: any, timeFormat: string | true) {
    if (dayjs(time).isValid()) {
      return timeFormat === true ? dayjs(time).format('YYYY-MM-DD') : dayjs(time).format(timeFormat)
    } else {
      return ''
    }
  }
```







#### **组件传递**

Vue组件的自我调用，称之为组件传递。原理相当于递归。DynamicColumn组件，本质上是element-ui 中的 el-table-column的封装。目的为了满足树形表格的需求。

注意组件调用必须要满足以下条件:

\1.     一定要注册组件名

![img](%E6%95%B4%E7%90%86.assets/clip_image002.jpg)

\2.     在本组件（如：DynamicColumn中）直接调用自己，所传参数与非同名组件是一样的。

![img](%E6%95%B4%E7%90%86.assets/clip_image004.jpg)

\3.     

一定要有判断自我调用的条件，否则会导致程序崩溃，相当于递归也需要一个结束递归的判断。



#### 疏通插槽

数据是一路往下传的，

header=> sortHeaders=>col

headers里的value 对应 eltable的prop，label（表头）对应text

 :label="col.text"		  :prop="col.value"





 **studentInfo**组件部分：

```js
        <template #operate="{ scope }">
          <el-button class="color-green" @click.native.stop="toDetail(scope.row, '详情')" type="text"
            >学员详情</el-button
          >
          <el-button class="color-green" @click.native.stop="toDetail(scope.row, '学习考试记录')" type="text"
            >考试记录</el-button
          >
        </template>
```

**Grid**组件部分：

```js
    <!-- 这是作用域插槽父组件里用的， -->

     <span v-if="item.slotName" :slot="item.slotName" slot-scope="{ scope }">

      <!-- 把上面的name、scope传给父了 -->

     <slot :name="item.slotName" :scope="scope"></slot>

    </span>
```

Grid中**dynamic-colum**组件部分：

```js
  <!-- elementui的el-col自带插槽，提供给你让你可以修改列内容格式的 -->
    <template slot-scope="scope">
      <div
        v-if="col.template"
        @click.stop="onTemplateClick($event, scope.row, index)"
        v-html="col.template(scope.row, index)"
      ></div>
      <html-content
        v-else-if="col.component"
        v-bind="$attrs"
        v-on="$listeners"
        :html="col.component(scope.row, index)"
        :row="scope.row"
        :index="index"
      ></html-content>
		.....
      <!-- 如果发现有携带的数据是插槽类型，就是提供占位符咯，也就是grid里index里的添加的作用域插槽 -->
      <slot v-else-if="col.slotName" :name="col.slotName" :scope="scope" />
    </template>
```

![image-20230629170732724](%E6%95%B4%E7%90%86.assets/image-20230629170732724.png)



高亮



### html-content组件

用render和jsx编写组内组件

来实现的自定义html内容和点击事件

```js
 <html-content
        v-else-if="col.component"
        v-bind="$attrs"
        v-on="$listeners"
        :html="col.component(scope.row, index)"
        :row="scope.row"
        :index="index"
      ></html-content>
```



传进去的header样子长这样，根据传进去的value类型，来决定字体样式

```js
   {
      value: 'status',
      text: '考试状态',
      component: (row: any) => {
        const html = `<div class="state-label state-taskStatus-${
          row.status === '待考试' ? 'yellow' : row.status === '未通过' ? 'red' : 'green'
        }">${row.status}</div>`
        return html
      }
    },
```



简单的用render和jsx编写组内组件

```js
  components: {
    htmlContent: {
      props: {
        html: String,
        row: Object,
        index: Number
      },
      render(h: any) {
        const self: Vue = this
        const component = Vue.extend({
          template: `<div @click.stop="onComponentClick">${self.$props.html}</div>`,
          methods: {
            onComponentClick() {
              this.$children.forEach((item: any) => {
                self.$emit(item.$attrs.clickName, self.$props.row, self.$props.index)
              })
            }
          }
        })

        return h(component, {
          // on: {
          //   click: function() {
          //     console.log(111)
          //     ;(self as any).aaa()
          //   }
          // }
        })
      }
    }
  }
```





## 详情页面、弹窗

## 文件上传

文件上传，下载，预览 TreeFile2为例

   [长沙市农业项目全生命周期管理系统 (申报端)](http://10.14.3.27:4933/crowd/replenishment?_key=1687940181646)

### 整体逻辑

![Snipaste_2023-07-06_10-21-48](%E6%95%B4%E7%90%86.assets/Snipaste_2023-07-06_10-21-48.png)

2部分是在upload的.then中，.then中调用的是handleSuccess方法，先放到变量里在点击页面的发布时，上传到业务数据库中，就是3的部分

[智慧农业农村云上资料库](http://10.14.3.27:4933/sub/subSystem-cloud/keyWork/list?menuId=12941)



- 1部分就是upload方法



const uploaderClass = new UploaderClass({

   files: [params.file],

   beforeUpload: () => data,

   fileExists: fileUploadExists,

   uploadChunk: fileUploadChunk

  })

签名this.signature属性在这里用上了



// 获取签名

 getSignature () {

  comService.getSignature({ storeId: 'op' }).then(res => {

   **this.signature** = res.data

   const { filePermissionVo, signature } = res.data

   **this.customAuth** = Object.freeze({ signature, filePermissionVo })

  })

 }





#### .start() 方法





```
  async start() {
    const beforeUploadData = (await this.beforeUpload()) || {}
    const res = []
    for (let i = 0, l = this.files.length; i < l; i++) {
      this.files[i].registerData(beforeUploadData)
      const data = await this.files[i].start(beforeUploadData)
      res.push(data)
    }
    return res
  }
```







- 2部分是在upload的.then中，.then中调用的是handleSuccess方法，先放到变量里在点击页面的发布时，上传到业务数据库中，就是3的部分



- 3部分	handleRelease方法 ，

  ```
    handleRelease () {
      // 任一表单项被校验后触发
      this.FormRef.validate().then((valid: boolean) => {
        let req: any
        if (this.isEdit) {
        是编辑就调更新接口
          req = jobUpdate(this.form)
        } else {
          req = importJobAdd(this.form)
        }
        req.then((res: any) => {
          this.$message.success(`${this.title}资料上传成功`)
          this.$xxTab.close()
          this.$xxTab.open('subSystem-cloud', '重点工作动态一览', {})
        })
      })
    }
  ```

  重点工作页面就是那个我的资料页面

### :on-success="handleSuccess"

on-success	文件上传成功时的钩子

把linkGuid文件名等信息，给到业务系统数据库中保存

```
  handleSuccess (res: any) {
    const { fileName, linkGuid } = res
    console.log(JSON.stringify(this.form.files, null, 2))
    const hasUploaded = this.form.files.find((item: any) => item.fileLinkId === linkGuid)
    console.log(linkGuid, fileName)
    if (!hasUploaded) {
      this.form.files.push({
        fileLinkId: linkGuid,
        fileName,
        name: fileName
      })
    }
  }
```



```
<div slot="file" slot-scope="{ file }" class="custom-file-item" @click="handlePreview(file)">
```

file传进函数里，长这样

![image-20230713194617272](%E6%95%B4%E7%90%86.assets/image-20230713194617272.png)

由:file-list="form.files"得来

form.files就是上传的文件



## 文件预览

[长沙市农业项目全生命周期管理系统 (申报端)](http://localhost:4933/crowd/projectDetailPage?_key=1689560935945)

在资料上传的新增资料里

在el-upload里使用了slot=file完成了自己重写了这个显示

![image-20230829100119447](%E6%95%B4%E7%90%86.assets/image-20230829100119447.png)



本来的：

![image-20230829100152242](%E6%95%B4%E7%90%86.assets/image-20230829100152242.png)





整段代码：

```vue
     <el-upload
              action=""
              accept=".pdf,.jpg,.png,.jpeg,.doc,.docx,.txt,.xls,.xlsx,.wps,.ofd"
              :file-list="form.files"
              :http-request="handleUpload"
              :on-success="handleSuccess"
              class="file-upload"
              :class="{ empty: !form.files.length }"
              multiple
            >
              <div class="upload-trigger">
                <span class="upload-icon"></span>
                上传文件,请<el-button size="small" type="text">点击上传 </el-button>
              </div>
              <div slot="file" slot-scope="{ file }" class="custom-file-item" @click="handlePreview(file)">
                <svg-icon class="icon-size-16" :icon-class="fileIcon(file.name)" />
                <span class="file-name ellipsis">{{ file.name }}</span>
                <span class="status">
                  <i class="el-icon-success"></i>
                  上传成功
                </span>
                <el-button
                  type="text"
                  class="del-btn"
                  icon="el-icon-delete"
                  @click.stop.prevent="handleBeforeRemove(file)"
                ></el-button>
              </div>
            </el-upload>
```







之前看的这个补正材料详情，现在没了

  [长沙市农业项目全生命周期管理系统 (申报端)](http://10.14.3.27:4933/crowd/replenishment?_key=1687940181646)

我的项目里的材料信息 projectDetailPage页面





### 纵览

鉴权、上传、回显、根据类型（pdf是用的插件）

[前端文件流、切片下载和上传：优化文件传输效率与用户体验 - 掘金 (juejin.cn)](https://juejin.cn/post/7255189826226602045)



点projectDetailPage 里的.nav-header就切换到材料信息显示 TreeFile2了

TreeFile2里写文件预览，数据来自projectDetailPage 依赖注入，点击文件位置有左键（双击？）和右键方法，传参给方法，让具体方法内容由projectDetailPage 写

```js
  // 打开附件材料预览弹窗 -> 通过父级调用
  showPreviewWindow(data: any) {
    if (!this.isPlenishment && !data.isWrite && data.isDir) {
      return
    }
    clearTimeout(timer)
    timer = null
    if (data?.isDir) return
    if (data) {
      // data.roles = node.roles
      this.selectedData = data
    }
    this.OPHandle.toggleAttachWindow(true, this.selectedData, false)
  }

```

toggleAttachWindow就是projectDetailPage 里的方法



WindowPreview在projectDetailPage 中

#####  @Provide() OPHandle: projectDetailPage = this	传给treeFile

父组件通过`provide/inject`给子孙组件传值



##### WindowPreview页面

里面有进度条		el-progress

由windowParams.loading控制



图片是用blob显示



#### TreeFile2的入参

```js
      <TreeFile2
        v-show="navActive === 2"
        class="el-overflow self-table"
        ref="treeFile"
        :disabledClick="false"
        :treeData="declareTreeData"
        :publickParam="treeParam"
        :isArchive="isArchive"
        :isOperation="false"
        @refreshInit="initDeclareTreeData"
      >
      </TreeFile2>
```

isOperation  控制TreeFile2的上传按钮的显示、和文件右边的删除icon

declareTreeData，可以看成文件夹----材料信息页面的数据里除了null的

来自

```js
 // 申报材料
  async initDeclareTreeData() {
   const { data }: any = await fetch.get('/xiangmu/prj/box/declareTree', {
```



```js
subParams值:
{
	"name":"JY0712测试项目",
	"projectKind":"农业企业升级发展项目",
	"projectType":"农业企业升级发展项目",
	"projectClassification":"农业企业升级发展项目（龙头企业）",
	"applyStatus":"审批中","applyType":"项目申报",
	"updateTime":"2023-07-12T08:48:41.735Z",
	"keyDigNumGather":"411926250768367616",
	"applyId":"843621702528208896",
	"projectCode":"411926250768367616",
	"thirdId":"8111",
	"applyUserId":"0",
	"canGetBack":true,
	"projectInfoType":1,
	"opinion":null
	}
```



```js
  this.treeParam 
  = {
      keyDigNumGather: this.subParams.keyDigNumGather || this.subParams.projectCode,
      keyTypeCode: this.subParams.keyTypeCode,
      procDefId: '',
      roles: []
    }
```



```js
DeclareTreeData的值
[
    {
        "id": "1",
        "label": "项目申报",
        "parentId": null,
        "materialTypeId": null,
        "fileLinkId": null,
        "fileSize": null,
        "isWrite": null,
        "isDir": true,
        "roles": null,
        "keyTypeCode": null,
        "keyDigNumGather": null,
        "subid": null,
        "children": [
            {
                "id": "1574581296242364418",
                "label": "营业执照",
                "parentId": null,
                "materialTypeId": "1574581296242364418",
                "fileLinkId": null,
                "fileSize": null,
                "isWrite": false,
                "isDir": true,
                "roles": [
                    "1571775970224902146"
                ],
                "keyTypeCode": 2,
                "keyDigNumGather": "411926250768367616",
                "subid": null,
                "children": [
                    {
                        "id": "411926517010202624",
                        "label": "习大大.png",
                        "parentId": null,
                        "materialTypeId": "1574581296242364418",
                        "fileLinkId": "411926516620914688",
                        "fileSize": "109719",
                        "isWrite": false,
                        "isDir": false,
                        "roles": [
                            "1571775970224902146"
                        ],
                        "keyTypeCode": 2,
                        "keyDigNumGather": "411926250768367616",
                        "subid": null,
                        "children": null
                    }
                ]
            },
            {
                "id": "1635184496867282945",
                "label": "其他",
                "parentId": null,
                "materialTypeId": "1635184496867282945",
                "fileLinkId": null,
                "fileSize": null,
                "isWrite": false,
                "isDir": true,
                "roles": [
                    "1571775970224902146"
                ],
                "keyTypeCode": 2,
                "keyDigNumGather": "411926250768367616",
                "subid": null,
                "children": []
            }
        ]
    }
]
```

#### 其他参数

##### 右键菜单

```js
 contextMenu: any[] = [
    {
      icon: 'x-yuedu',
      text: '预览',
      handler: (data: any) => {
        this.showPreviewWindow(data)
      },
      isFile: true
    },
    {
      icon: 'x-shangchuan4',
      text: '上传',
      handler: () => {
        ;(this.$refs.upload as any)?.$children?.[0].$refs.input.click()
      },
      isDir: true
    },
    {
      icon: 'x-shuaxin2',
      text: '刷新',
      handler: () => this.$emit('refreshInit')
    },
    {
      icon: 'x-xiazai3',
      text: '下载',
      handler: (data: any) => this.download(data)
    },
    {
      icon: 'x-daiban-xuanzhong',
      text: '签章',
      handler: (data: any) => this.handleSign(data)
    },
    {
      icon: 'x-bianji1',
      text: '重命名',
      handler: (data: any) => {
        this.showReName(data)
      }
    },
    {
      icon: 'x-shanchu',
      text: '成果作废',
      handler: (data: any) => this.cancelAchievement(data)
    },
    {
      icon: 'x-laji1',
      text: '删除',
      handler: (data: any) => this.remove(data)
    }
  ]
```



### TreeFile2内容







```js
 <div
        slot-scope="{ node, data }"
        class="tree-node"
        @click.stop="chooseed(data, node)"
        @dblclick.stop="showPreviewWindow(data, node)"
        @contextmenu="contextMenuFliter(data)"
        v-context-menu="{ contextMenu, data }"
      >
```

单击选中某一个文件 双击预览，

#### 单击逻辑

一键阻止事件冒泡，只让它执行我们的函数





#### 双击

```js
  showPreviewWindow (data: any) {
    if (!this.isPlenishment && !data.isWrite && data.isDir) {
      return
    }
    clearTimeout(timer)
    timer = null
    if (data?.isDir) return
    // 可写，不是文件夹
    if (data) {
      // data.roles = node.roles

      this.selectedData = data
    }
    this.OPHandle.toggleAttachWindow(true, this.selectedData, false)
  }
```





#### 右键

通过不允许点击文件夹实现禁用上传等--

**实现：**

```js
  @contextmenu="contextMenuFliter(data)"
  v-context-menu="{ contextMenu, data }"
```

绑定右键菜单事件，点右键时会对菜单做个过滤，contextMenuFliter方法

```js
  contextMenuFliter (data: any) {
    this.selectedData = data
    this.filterAcceptFun(data.materialSuffixes)
```

##### filterAcceptFun方法

```js
  filterAcceptFun (str: string) {
    if (str?.length > 3) {  
  //      attrs: any = {
  //        accept: '.'
  //        }
  // 将字符串 str 中的分号 ; 替换为逗号 ,，再将星号 * 替换为空字符串
      this.attrs.accept = str?.replace(/;/g, ',')?.replace(/\*/g, '')
    } else {
      this.attrs.accept = '.'
    }
  }
```

replace方法，正则表达式



##### contextmenu

[Element: contextmenu event - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/contextmenu_event)

**`contextmenu`** 事件会在用户尝试打开上下文菜单时被触发



##### setCurrentNode

通过 node 设置某个节点的当前选中状态，使用此方法必须设置 node-key 属性

(node) 待被选节点的 node

```
 this.tree?.setCurrentNode(data)
```



点击预览就调toggleAttachWindow，如果可写且不是文件夹

调注入过来的父级方法

```
 this.OPHandle.toggleAttachWindow(true, this.selectedData, false)
```







### WindowPreview文件预览详情页面

带着问题去看

文件上传怎样实现预览功能、需要监听哪些事件

图片预览怎么实现的，加载栏怎么实现的

数据selectedAttach来自这

```js
//就是传的点击的这个，data
@dblclick.stop="showPreviewWindow(data, node)"
 这个data来自 :data="treeData"
这个treeData来自	@Prop() treeData!: any
这个treeData来自父组件传入，:treeData="declareTreeData"
这个来自api请求的，  async initDeclareTreeData () {
    
```

图片预览的初始化是怎么显示的

```js
这么调用的
created
 this.currentFile = this.selectedAttach

 
//this.selectedAttach就是当前文件
 mounted () {
  this.onSelect(this.selectedAttach)


```

#### onSelect方法里

判断文件类型，设定时器让进度条执行，鉴权

请求previewTree的api

```js
//res长这样
{data: Blob, status: 200, statusText: 'OK', headers: {…}, config: {…}, …}
config
: 
{transitional: {…}, transformRequest: Array(1), transformResponse: Array(1), timeout: 1000000, adapter: ƒ, …}
data
: 
Blob
size
: 
109719
type
: 
"image/png"
[[Prototype]]
: 
Blob
headers
: 
{access-control-allow-methods: '*', access-control-allow-origin: '*', cache-control: 'max-age=180, public', connection: 'close', content-disposition: 'inline;filename="411926516520251392_.png.png"', …}
request
: 
XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 1000000, withCredentials: false, upload: XMLHttpRequestUpload, …}
status
: 
200
statusText
: 
"OK"
[[Prototype]]
: 
Object
```

then方法中赋windowParams--loadingPercent: 100

```
 this.windowParams = {
          ...this.windowParams,
          tips: '',
          ifError: false,
          loadingPercent: 100
        }
```



最后loading: false吧进度条取消

```
.finally(() => {
        setTimeout(() => {
          this.windowParams = {
            ...this.windowParams,
            loading: false
          }
```





页面用el-dialog实现



:**before-close**="dialogBeforeClose"

 // 实现关闭弹窗

 dialogBeforeClose() {

  this.visible = false

 }



if -else  进度条和图片页面

图片页面里包含前进后退箭头



放大缩小函数，过会看

scale (val: number, step = 0.2) {



 // 鼠标左键按下拖动平移

 handleMove (event: any) {





## 移动端

瀑布流显示处理



选项展开逻辑



返回记得加原生

back.native ="back"

给vue组件绑定事件时候，必须加上native ，不然不会生效（监听根元素的原生事件，使用 `.native` 修饰符）



### JsBridge

```js
/** 上传照片 */
export const getPhoto = (params: any) => {
  return new Promise((resolve) => {
    window.WebViewJavascriptBridge?.callHandler('getPhoto', params, (res: any) => {
      resolve(res)
    })
  })
}

```

Native可以在H5页面中注入一个全局对象，里面实现了很多Api，在H5页面中就可以调用这些方法。

Native还可以在H5页面中执行一段js代码，H5可以提前准备好一个全局对象，实现对应的Api，等Native执行js语句从而调用H5对应的Api

[(9 封私信 / 80 条消息) 千锋前端学习营 - 知乎 (zhihu.com)](https://www.zhihu.com/org/qian-feng-html5xue-yuan/posts?page=3)





```js
export const openOneMapWithOpenLayers = (params: any) => {
  return new Promise((resolve) => {
    window.WebViewJavascriptBridge?.callHandler('openOneMapWithOpenLayers', params, (res: any) => {
      resolve(res)
    })
  })
}
```





## 公文事务打印

在9_18里

iframe ， 流程（word是怎么拿到文件、保存文件的；pdf的文件获取blob），http





## 台账List

### 高亮

TzTableBox.vue里传入了个keyWord



有个highlight，

```vue
<el-table-column    >
    //v-html也会替代{{}}的内容
	<span v-else v-html="highLight(scope.row[scope.column.property], scope.column.property)">{{
              scope.row[scope.column.property]
            }}
    </span>
    
</el-table-column>


highLight(val: any) {
    if (!val) return
    return htmlUtil.highlight(val, this.keyWord)
  }
```



```js
const htmlUtil = {
  highlight: (val: any, keyword: any) => {
    if (!val) {
      return ""
    }

    if (!keyword) {
      return val
    }

    if (typeof val !== "string") {
      return val
    }

    const regExp = new RegExp(keyword, "i")
    //忽略大小写的去val里找keyword，找到了就把val里的对应的替换成第二个参数
    return val.replace(regExp, `<span style="color: red;">${keyword}</span>`)
  }
}

export { htmlUtil }

```





封装组件

DList留个心眼



## 迁移子系统

多页面的vue项目







换路由

首页换掉





一个项目多个系统的配置（入口配置）

vue.config.js



如公众端（crowd）

会进入crowd_main.ts里配置所有东西，在这引入了所有路由和插件

但我这里没认我的这个文件   --重新build再运行，更改了vue.config.js都要这样

![image-20231102100057263](%E6%95%B4%E7%90%86.assets/image-20231102100057263.png)



所以我进这



**模块配置**

加新模块时需要在/lib/loader.ts里添加规则





# HTML

### editable

```html
<cite contenteditable="true">-- Write your own name here</cite>

```

让文本是可编辑的

[contenteditable - HTML（超文本标记语言） | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable)



# CSS

### 背景渐变

#### linear-gradient()

CSS **`linear-gradient()`** 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于[``](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient)数据类型，是一种特别的[``](https://developer.mozilla.org/zh-CN/docs/Web/CSS/image)数据类型。

```css
.simple-linear {
  background: linear-gradient(blue, pink);
}
```



### 文字省略

[css文字超出元素省略,单行、多行省略 - 掘金 (juejin.cn)](https://juejin.cn/post/7016631393165770759)

沪上阿姨那个下面的文字省略

 overflow: hidden;

 white-space: nowrap;

 text-overflow: ellipsis;



​	四行：overflow：hidden...

###  cursor: pointer;

设置光标类型



### calc()

```js
<div>

	<div class="head">标题</div>
	<div class="contain">内容</div>

</div>
<style>
	.head{
		height: 70px;
	}
	.contain{
		height: calc(100% - 170px);;
	}
</style>
```


对于以上代码，如果我们要让盒子中的“内容”占满“标题”以下的所有区域，可以给“标题”设置一个固定值（70px），然后让“内容”的高为100%减去“标题”的高度，只需要设置样式使用calc() 函数就可以了！

使用calc()函数时需要注意以下几点：

1. calc()函数用于动态计算长度值。
2. **calc()函数支持 “+”, “-”, “*”, “/” 运算，运算符前后都需要保留一个空格**。
3. calc()函数使用标准的数学运算优先级规则。

————————————————
版权声明：本文为CSDN博主「心。晴」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jingjing217/article/details/107963876



### **white-space: nowrap;**

主要目的就是让文字不换行吧

**所有空格、回车、制表符都合并成一个空格，文本不换行**

床(空格)前(空格)(空格)(空格)(空格)明月光，疑是地上霜
（回车）
举头望明月，低头(Tab)思故乡

![img](%E6%95%B4%E7%90%86.assets/6100773-79b94479e8d415dd.png)



### position定位

定位：position  是relative才有before？这是为什么，去过一过position

好像是子绝父相的东西？--用这个的意义

`static`是`position`属性的默认值。如果省略`position`属性，浏览器就认为该元素是`static`定位。其他三个都是相对于某个基点的定位



相对定位/绝对定位 才有那四个属性

relative  相对于默认位置（即`static`时的位置）进行偏移，即定位基点是元素的默认位置 去设置top、bottom，left、right





![image-20230913113607085](%E6%95%B4%E7%90%86.assets/image-20230913113607085.png)



 position 设置为absolute/fixed  脱离标准流，在文档流中不占位，宽高由内容定。不占用父空间了，父元素不会被其撑开，

**absolute** 基于父位置，父写个relative 就是给子元素参考位置吧？***\*大概就是先把父设置为定位点\****

（它有一个重要的限制条件：定位基点（一般是父元素）不能是`static`定位，否则定位基点就会变成整个网页的根元素`html`。另外，`absolute`定位也必须搭配`top`、`bottom`、`left`、`right`这四个属性一起使用。）

**希望子元素相对于父元素进行定位，又不希望父元素脱标的时候，我们才会会用到子绝父相。**



相对定位是没有脱标的，其最典型的应用就是来限制绝对定位



**fixed** 	定位基点是浏览器窗口，不随页面滚动而变化，好像固定在网页上一样



sticky动态固定，像`relative`和`fixed`的结合，必须搭配`top`、`bottom`、`left`、`right`这四个属性一起使用，不能省略，否则等同于`relative`定位

```css
  position: sticky;
  top: 0; 
```

[阮一峰博客CSS position定位（relative、absolute、fixed）属性教程，sticky竟有此神奇妙用！-甲爸博客 (xiaoyunhua.com)](https://www.xiaoyunhua.com/4302.html)







### overflow 

overflow: auto;	还是没弄懂滚动要加在哪，老是要去试

[overflow:auto 不生效的原因_overflowauto不生效_sdewendong的博客-CSDN博客](https://blog.csdn.net/sdewendong/article/details/84432778)

就是我发现不是给不给overflow的问题，是给没给高度的问题，我高度给的区域对，自然就出现了

**overflow：auto；如果内容被修剪，则浏览器会显示滚动条，以便查看其余内容。**

​	因为我之前给的是100%，应该就是100%的原因，映射出来不是px值，所以默认没有修剪





### after细线的样式逻辑：

因为其他没设，放大缩小默认是0，所以它设flex：1就占满了剩余空间

再把高度设为1，背景设为黑色，就成了细线

内容content：‘’





### 页面响应式

flex布局



### flex布局

flex	flex布局对于容器的控制是基于轴这个概念的	flex中的轴分为：主轴、垂直轴、换行轴。

下面的可以分为两组：一组去控制轴、一组去控制轴上的元素

- flex-direction	 row | row-reverse | column | column-reverse;
- flex-wrap    如果一条轴线排不下，如何换行
- flex-flow   上面两个的属性简写，默认值为`row nowrap`。



- justify-content    flex-start | flex-end | center | space-between | space-around;
- align-items



- align-content		定义了多根轴线的对齐方式。只有一根轴线该属性不起作用。

#### flex属性

`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。

> ```css
> .item {
>   flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
> }
> ```

该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。

**flex: 1; === flex: 1 1 0;**

### **BFC**

BFC - Block Formatting Context 块级格式化上下文

一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素

解决塌陷问题（margin、浮动塌陷）

100+100不等于200问题

​		把塌陷区域分开放进两个BFC



**BFC可以阻止标准流元素被浮动元素覆盖**

利用创建一个新的BFC来消除浮动带来的影响

**触发BFC的条件**

​		5+2

·body根元素

·设置浮动，不包括none

·设置定位，absoulte或者fixed

·弹性布局，flex

·设置overflow，即hidden，auto，scroll



·行内块显示模式，inline-block

·表格单元格，table-cell





[BFC是什么？10 分钟讲透BFC 原理 (itcast.cn)](https://www.itcast.cn/news/20201016/16152387135.shtml)

[面试官：谈谈你对BFC的理解？ · Issue #99 · febobo/web-interview · GitHub](https://github.com/febobo/web-interview/issues/99)



### 伪类和伪元素

伪类，单冒号，表状态（:hover、active、visited）

（记得有一类笔试题是问你伪类的执行顺序的）

伪元素，双冒号，是真的有元素（`::before` 用于在选中元素的内容之前插入生成的内容）





### VUE`<Transition>` 组件及CSS动画

`<Transition>` 

会在一个元素或组件进入和离开 DOM 时应用动画。

是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上。进入或离开可以由以下的条件之一触发：



1. `v-enter-active`：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。

2. 案列

   ```
   /*
     进入和离开动画可以使用不同
     持续时间和速度曲线。
   */
   .slide-fade-enter-active {
     transition: all 0.3s ease-out;
   }
   ```

   ...	...	...

```
.dialog-fade-enter-active {
 animation: dialog-fade-in 0.3s;
}

.dialog-fade-leave-active {
 animation: dialog-fade-out 0.3s;
}

@keyframes dialog-fade-in {
 0% {
  transform: translate3d(0, -20px, 0);
  opacity: 0;
 }
 100% {
  transform: translate3d(0, 0, 0);
  opacity: 1;
 }
}



@keyframes dialog-fade-out {

 0% {

  transform: translate3d(0, 0, 0);

  opacity: 1;

 }

 100% {

  transform: translate3d(0, -20px, 0);

  opacity: 0;

 }

}
```



##### CSS 的 animation[](https://cn.vuejs.org/guide/built-ins/transition.html#css-animations)

[原生 CSS 动画](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)和 CSS transition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。

#### css动画

关键帧

[使用 CSS 动画 - CSS：层叠样式表 | MDN (mozilla.org)](







































# JS

[FormData 对象的使用 - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects)



## 数据类型

根据 JavaScript 中的变量类型传递方式，分为**基本数据类型**和**引用数据类型**两大类七种。

 基本数据类型六种，**Undefined**、**Null**、**Boolean**、**Number**、**String**、**Symbol（ES6新增） **  

 ***引用数据类型只有*Object一种**，主要包括对象、数组和函数

### 基本数据类型和引用数据类型有什么区别？

  （1）两者作为函数的参数进行传递时：
     基本数据类型**传入的是数据的副本**，原数据的更改不会影响传入后的数据。
     引用数据类型**传入的是数据的引用地址**，原数据的更改会影响传入后的数据。
   （2）两者在内存中的存储位置：
     基本数据类型**存储在栈中**。
     引用数据类型在**栈中存储了指针**，该指针指向的**数据实体存储在堆中**。



**typeof**就是判断数据类型的

null 也是object	？





**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。





链接：https://juejin.cn/post/6913022820691738631



## 隐式转换 

加法转换规则：由高到低

- 当一侧为`String`类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。
- 当一侧为`Number`类型，另一侧为原始类型，则将原始类型转换为`Number`类型。
- 当一侧为`Number`类型，另一侧为引用类型，将引用类型和`Number`类型转换成字符串后拼接。



this.pieDataTotal += +element

+element  相当于 0+element，类型转化：如果element是string 那么会被转话为数字类型



  在 JS 中，只有 0，-0，NaN，""，null，undefined 这六个值转布尔值时，结果为 false，



只有 `null` `undefined` `''` `NaN` `0` `false` 这几个是 `false`

{}，[]为true



### 使用 == 比较中的5条规则

⭐️根据 `==` 两侧的数据类型，我们总结出 5 条规则：

- 规则 1：`NaN`和其他任何类型比较永远返回`false`（包括和他自己）。

```javascript
NaN == NaN // false
```

- 规则 2：Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。

```javascript
true == 1  // true 
true == '2'  // false, 先把 true 变成 1，而不是把 '2' 变成 true
true == ['1']  // true, 先把 true 变成 1， ['1']拆箱成 '1', 再参考规则3
true == ['2']  // false, 同上
undefined == false // false ，首先 false 变成 0，然后参考规则4
null == false // false，同上
```

- 规则 3：`String`和`Number`比较，先将`String`转换为`Number`类型。

```javascript
123 == '123' // true, '123' 会先变成 123
'' == 0 // true, '' 会首先变成 0
```

- 规则 4：`null == undefined`比较结果是`true`，除此之外，`null`、`undefined`和其他任何结果的比较值都为`false`。

- 规则 5：`原始类型`和`引用类型`做比较时，引用类型会依照`ToPrimitive`规则转换为原始类型。

[JavaScript 隐式类型转换，一篇就够了！ (freecodecamp.org)](https://www.freecodecamp.org/chinese/news/javascript-implicit-type-conversion/)



[] == ![] 为 true

=> [] == false

=>[]==0

=>''==0



## ==、===

#### 等于操作符

- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
- 两个都为引用类型，则比较它们是否指向同一个对象
- null 和 undefined 相等
- 存在 NaN 则返回 false

#### 全等操作符

全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同

相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换



### 深浅拷贝

出现原因：基本类型数据保存在在栈内存中，引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中

#### 浅

##### Object.assign

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// Expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget === target);
// Expected output: true				
```

感觉和拓展运算符差不多

**目标对象只有一层的时候，是深拷贝；**

深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份

#### 深

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性



## Array

slice(start,end)

左闭右开	（包括 `start`，不包括 `end`）

负号表示倒数







## filter

​    // filter() 方法，过滤规则是return的内容

​    // 第⼀个参数是⾥⾯的元素,第⼆个参数为元素索引值,第三个参数为数组本⾝

```js
  =  this.recordFileList = list.filter((item: any) => item.fileName && item.fileLink)

​    const temp = list.filter((e: any) => e.meetingProcess) 

​    this.meetingRecordList = temp.reduce((pre: any, cur: any) => {

​     // debugger

​     if (!pre.includes(cur.meetingProcess)) pre.push(cur.meetingProcess)

​     return pre

​    }, [])


```





## JS循环大总结， for, forEach，for in，for of, map

[从for in 和for of的区别吹到async await - 掘金 (juejin.cn)](https://juejin.cn/post/7241838768016605244?searchId=2023073108420003A71227E1225F90FD36#heading-0)







```js
  async getUserList() {
    const res = await getUserList()
    const userList = res.data || []
    this.userOptions = Object.entries(userList).reduce((pre, [name, children]) => {
      pre.push({ userName: name, children, userId: guid() })
      return pre
    }, [] as any)
    console.log(this.userOptions)
  }
```





### for  in（大部分用于对象）

js出现就有了

**遍历对象键值(key，只有这一个参数),或者数组下标,不推荐循环一个数组**

**`for...in`** **语句**以任意顺序迭代一个对象的**除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性**，包括继承的可枚举属性。

`for ... in`是**为遍历对象属性而构建**的，不建议与数组一起使用（因为会把原型链上的东西也遍历上去），数组可以用`Array.prototype.forEach()`和`for ... of`，

那么`for ... in`的到底有什么用呢？





但我实际操作时发现是不能对**数组**操作的

**备注：** `for...in`不应该用于迭代一个关注索引顺序的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)。

（因为使用`for in`会遍历数组所有的可枚举属性，包括原型）

```
for (variable in object)
  statement
  
  
variable
在每次迭代时，variable 会被赋值为不同的属性名。

object
非 Symbol 类型的可枚举属性被迭代的对象。
```



### for...of（不能遍历对象）

es6中的，**遍历的只是数组内的元素（加[]为[i,v]）**，不包括原型属性和索引,允许遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等.在 ES6 中引入的 for of 循环，以替代 for in 和 forEach() ，并支持新的迭代协议。



由来：

​	for...in 虽然是给对象用的，但它可以给数组用吗（可以）

for...of  可以遍历对象吗，不行，为什么，引出来

​	es6可迭代对象



#### 两者区别

`for in` 用于遍历对象的键(`key`)，`for in`会遍历所有自身的和[原型链](https://www.zhihu.com/search?q=原型链&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A3138833697})上的可枚举属性。如果是数组，for in会将数组的索引(index)当做对象的key来遍历，其他的object也是一样的。  `for of`是`es6`引入的语法，用于遍历 所有[迭代器](https://www.zhihu.com/search?q=迭代器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A3138833697})iterator，其中包括`HTMLCollection`,`NodeList`,`Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments`等对象的值(`item`)。

链接：https://www.zhihu.com/question/573766083/answer/3138833697




`for of`适用遍历数/数组对象/字符串/`map`/`set`等拥有迭代器对象（`iterator`）的集合，但是不能遍历对象，因为没有迭代器对象，但如果想遍历对象的属性，你可以用`for in`循环（这也是它的本职工作）或用内建的`Object.keys()`方法



[for...in - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)



[Object.prototype.hasOwnProperty() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)







[JS filter、map、reduce等十三种遍历数组方法详细总结🔥 - 掘金 (juejin.cn)](https://juejin.cn/post/7241875961130745911?searchId=20230728165000E73BF392152FF8C4C330#heading-2)

数组归并方法reduce()和reduceRight()。两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后，reduceRight()从数组的最后一项开始，向前遍历到第一项



### 数组迭代方法

- forEach是对数组的每一个元素执行一次给定的函数。
- map是创建一个新数组,该新数组由原数组的每个元素都调用一次提供的函数返回的值。

##### forEach()

只能对数组使用

对数组每一项都运行传入的函数，没有返回值

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
numbers.forEach((item, index, array) => {
    // 执行某些操作
});

arr[index] = item
```

```js
.forEach((item, index) => {
```



##### map()

**`map()`** 方法**创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let mapResult = numbers.map((item, index, array) => item * 2);
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
```



`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

```
or (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
```

在这放一起总结

对象的这些方法也是一样的,写成这样--Object.entries（obj）



### reduce

对数组累计操作

方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

#### 语法

```
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
```

#### 参数

| 参数                                      | 描述                               |
| :---------------------------------------- | :--------------------------------- |
| *function(total,currentValue, index,arr)* | 必需。用于执行每个数组元素的函数。 |
| *initialValue*                            | 可选。传递给函数的初始值           |

function

| 参数           | 描述                                     |
| :------------- | :--------------------------------------- |
| *total*        | 必需。*初始值*, 或者计算结束后的返回值。 |
| *currentValue* | 必需。当前元素                           |
| *currentIndex* | 可选。当前元素的索引                     |
| *arr*          | 可选。当前元素所属的数组对象。           |

这里说的初始值init就是方法逗号后面的那个初始值*initialValue*

 pre（total）：上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 init，其值则为 init，否则为数组索引为 0 的元素 arr[0]。

cur：数组中正在处理的元素。在第一次调用时，若指定了初始值 init，其值则为数组索引为 0 的元素 arr[0]，否则为 arr[1]。
 index：数组中正在处理的元素的索引。若指定了初始值 init，则起始索引号为 0，否则从索引 1 起始。
 arr：用于遍历的数组。

https://blog.csdn.net/qq_52855464/article/details/126004138

[JS filter、map、reduce等十三种遍历数组方法详细总结🔥 - 掘金 (juejin.cn)](https://juejin.cn/post/7241875961130745911?searchId=20230728165000E73BF392152FF8C4C330#heading-2)







### 对象

`for...of` 语句用于遍历可迭代对象	(也能对数组用吧)

```
// 迭代映射对象
const map = new Map([["name", "John"], ["age", 30]]); 
for (const [key, value] of map) { 
    console.log(key, value); 
}
// name John
// age 30
```

这个博客写的真垃圾





## this指向

[JavaScript中this指向详细分析(译) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/431472497)

箭头函数 this 会指向它所定义的地方，因此如果我们在使用一些框架，比如 Vue、小程序，在定义钩子函数或者属性方法的时候千万不能用箭头函数。

```javascript
export default {
    data() {
        return {
            a: 1,
        };
    },
    methods: {
        test: () => {
            console.log(this.a)
        },
    },
};export default {
    data() {
        return {
            a: 1,
        };
    },
    methods: {
        test: () => {
            console.log(this.a)
        },
    },
};
```

test 方法中是无法访问到 a 属性的，小程序中定义函数的时候也是同理。







类里面的 this 指向问题。
constructor 里面的 this 指向实例对象, 方法里面的 this 指向这个方法的调用者。





默认

在函数里面用this，this对象就是window对象，

严格模式下，不能将全局对象用于默认绑定

隐式

对象方法里用this，this指向的是**上一级对象**

只会是上一级

new

构建函数`new`关键字生成一个实例对象，此时`this`指向这个实例对象

new return是对象，的`this`指向为返回的对象

普通的不会返回

显式

apply()、call()、bind()

箭头函数





## staic



静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 **类名.方法名** 调用静态方法。（就跟Array.isArray的道理一样吗）

静态方法不能在对象上调用，只能在类中调用。

- #### `static` 使用方法总结

  - ### 静态方法 应该在 没有实例化的时候调用

  - ### 反而言之：静态方法不能在类的实例中使用



[JavaScript static 关键字是干嘛的？ - 掘金 (juejin.cn)](https://juejin.cn/post/6940556583482949663)



## 事件循环event loop

是JavaScript引擎中来管理异步操作的机制。它使得JavaScript能够处理非阻塞的I/O操作和其他异步任务，以保持程序的响应性

他的核心思想就是将任务分成同步任务和异步任务两大类，

所有同步任务都在主线程上执行,形成一个技术栈(execution context stack)。

主线程之外,还存在一个"任务队列"(task queue)。只要异步任务有了运行结果,就在"任务队列"中放置一个事件。

它循环的具体步骤就是：

先执行同步任务直到全部完成，当主线程中的任务运行完了，才会从”任务队列”取出异步任务放入主线程执行，

然后取异步任务也会根据宏微任务的规则去取，规则就是微任务可以插队，会优先执行微任务，然后如果执行完一个宏任务时，如果任务队列里有微任务，它可以立马插队插进去

主线程不断重复上面的第三步。
链接：https://juejin.cn/post/7048512716180291615

## js异步的宏微任务

微任务：Promise 回调函数（Promise.then()）（Promise本身是同步任务），宏任务：setTimeout 回调函数

项目开发中，遇到了定时器回调函数定时为0也能达到效果，达到页面数据请求完整，成功渲染（项目中的应用就是开新页面前请求数据在定时器中请求）

[js宏任务和微任务执行顺序详解 - 掘金 (juejin.cn)](https://juejin.cn/post/7219689062449446971)

`js` 在主线程中执行的顺序：宏任务 -> 宏任务 -> 宏任务 ...

宏任务和微任务在一个执行栈中执行，它们都会在里面排队等待执行，但宏任务的优先级是01，微是10（**微的更高**），所以有微任务就会在当前宏任务执行完后就执行

（微任务能插队，当一个宏任务处理完后，就要处理还有的微任务，处理完所有的微后才能处理下一个宏）

在每一个宏任务中又可以产生微任务，当微任务全部执行结束后执行下一个宏任务。 【宏任务 [微任务]】 -> 【宏任务 [微任务]】-> 【宏任务 [微任务]】

1. 先执行同步和立即执行任务，比如说`console.log()、new Promise()`

2. 再依次执行微任务，比如说`thenable`函数和`catchable`函数

3. 当微任务执行完成后开始执行宏任务，比如说`定时器、事件回调`等

   await`命令就是内部`then`命令的语法糖，而then是咱们写的事件回调函数，就丢到微任务里了

   [(190条消息) 宏任务和微任务的一道经典面试题~_不二博客的博客-CSDN博客](https://blog.csdn.net/qq_39157944/article/details/105157472)



[(190条消息) 执行栈 同步任务 异步任务 宏任务 微任务 总结（含面试讲解）_孟章丶的博客-CSDN博客](https://blog.csdn.net/weixin_56119039/article/details/131781228?spm=1001.2014.3001.5501)

```JavaScript
async function method() {
  await method2();
  console.log(1)
}

function method2() {
  const promise = new Promise((resolve) => {setTimeout(() => resolve(), 0)});
  return promise;
}

function main() {
  method()
  console.log(2)
}

main()
```

2,1

微任务不是立即执行的----- method2()被调用风放进微任务里，然后返回回来就执行console.log(2)了

[JS事件循环机制（event loop）之宏任务/微任务 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903638238756878?searchId=20230717202441B6AAD292375E5C34690A#comment)







```js
const t1 = new Date()
setTimeout(() => {
    const t3 = new Date()
    console.log('setTimeout block')
    console.log('t3 - t1 =', t3 - t1)
}, 100)
​
​
let t2 = new Date()
​
while (t2 - t1 < 200) {
    t2 = new Date()
}
​
console.log('end here')

```

输出答案是 `200`。

整个脚本是第一个宏任务。计时器生成了第二个宏任务。只有第一个宏任务执行结束后才会执行第二个宏任务。





[JavaScript中this指向详细分析(译) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/431472497)

箭头函数 this 会指向它所定义的地方，因此如果我们在使用一些框架，比如 Vue、小程序，在定义钩子函数或者属性方法的时候千万不能用箭头函数。

```javascript
export default {
    data() {
        return {
            a: 1,
        };
    },
    methods: {
        test: () => {
            console.log(this.a)
        },
    },
};export default {
    data() {
        return {
            a: 1,
        };
    },
    methods: {
        test: () => {
            console.log(this.a)
        },
    },
};
```

test 方法中是无法访问到 a 属性的，小程序中定义函数的时候也是同理。









只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。



**题目在博客中**

过一遍执行栈，先执行同步任务

console.log("同步任务1");

workFun()

```
console.log("同步任务2");
    if (mac) {
        console.log(mac);
    }
    return new Promise((resolve, reject) => {
        console.log("Promise中的同步任务");
        resolve("Promise中回调的异步微任务")
    })

```

console.log("同步任务3")



排好了不进入主线程的异步任务

```
宏任务：setTimeout， then(res => {    console.log(res); })

微任务：workFun()里嵌套微任务---- resolve("Promise中回调的异步微任务")

```



先执行所有同步任务，产生结果：

 console.log("Promise中的同步任务")为什么会先执行，----这是promise的

而resolve("Promise中回调的异步微任务")没执行--还在执行同步函数，这是个异步

```
同步任务1 
（执行同步任务workFun函数）
同步任务2
Promise中的同步任务
同步任务3
```



执行完同步任务，开始异步任务，执行当前所有微任务，产生结果：

```
Promise中回调的异步微任务
```



执行排好队的宏任务，也就是

setTimeout

 then(res => {    console.log(res); })



执行先前排队的setTimeout，依次执行里面的同步任务

```
console.log("异步任务中的宏任务");
workFun("定时器传递任务")
```

又排了两个宏任务，

```
setTimeout(() => {        console.log("定时器中的定时器（宏任务）");     }, 

console.log("异步任务中的宏任务");
```

此时宏任务：

.then(res => {        console.log('定时器中的:', res);    })

setTimeout(() => {        console.log("定时器中的定时器（宏任务）");     }, 



产生结果：

```
异步任务中的宏任务
同步任务2
定时器传递任务
```



执行workFun里的同步任务后，执行workFun里的微任务

产生结果：

```
Promise中的同步任务
```



继续执行宏任务：

1. 

   ```
    workFun("定时器传递任务").then(res => {        console.log('定时器中的:', res);    })
   ```

2. ```
   setTimeout(() => {        console.log("定时器中的定时器（宏任务）");     }, 0)
   ```

   



产生结果：.then(res => {        console.log('定时器中的:', res);    })

```
定时器中的: Promise中回调的异步微任务
定时器中的定时器（宏任务）
```







## Blob	

[JavaScript中的Blob你知道多少 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/500199997)

**一、Blob 是什么**

Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。**在 [JavaScript](https://link.zhihu.com/?target=http%3A//caibaojian.com/t/javascript) 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。**



### **2.2 属性**

前面我们已经知道 Blob 对象包含两个属性：[·](https://link.zhihu.com/?target=http%3A//caibaojian.com/blob.html)

- size（只读）：表示 `Blob` 对象中所包含数据的大小（以字节为单位）。
- type（只读）：一个字符串，表明该 `Blob` 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。

### **2.3 方法**

- slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。
- stream()：返回一个能读取 blob 内容的 `ReadableStream`。
- text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 `USVString`。
- arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 `ArrayBuffer`。

这里我们需要注意的是，**`Blob` 对象是不可改变的**。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。



### **三、Blob 使用场景**

### **3.1 分片上传**

File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下

### **3.2 从互联网下载数据**

我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，

### **3.3 Blob 用作 URL**

Blob 可以很容易的作为 `<a>`、`<img>` 或其他标签的 URL，多亏了 `type` 属性，我们也可以上传/下载 `Blob` 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。

**1.Blob URL/Object URL**

Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 `URL.createObjectURL` 方法来创建 Blob URL，该方法接收一个 `Blob` 对象，并为其创建一个唯一的 URL，其形式为 `blob:<origin>/<uuid>`，对应的示例如下：

blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641

浏览器内部为每个通过 `URL.createObjectURL` 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 `Blob`。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 `<img>`、`<a>` 中的 `Blob`，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。[·](https://link.zhihu.com/?target=http%3A//caibaojian.com/blob.html)

上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。

但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。

针对这个问题，我们可以调用 `URL.revokeObjectURL(url)` 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。





## 防抖节流

防抖：搜索栏联想词	（只要最后一次？）

节流：技能冷却中		（只要第一次？）



防抖

闭包存定时器，return function

存this，调用方法时apply要用上的



每次调用时，如果有定时器在，就重新计时

```js
if (timer) clearTimeout(timer)
timer = setTimeout(O => [fn.apply(context，args)}，wait)
```





节流

```js
function thorttled(fn,delay){
  let timer = null
  let startTime = Data.now()
  return function(){
    let that = this
    let curTime = Data.now()
    let remaining = delay - (curTime -startTime)
    clearTimeout(timer)
    
    if(remaining<=0){
      fn.apply(that,arguments)
      startTime = Data.now()
    }
    else{
      timer = setTimeout(fn,remaining)
    }
  }
}
```





## 编程技巧

单个的条件判断从if变成&&运算

```js
  conditions.length && (query.conditions = conditions)
```





多个的或运算用includes()





# ES6

[变量的解构赋值 - ECMAScript 6入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/destructuring)

https://blog.csdn.net/weixin_44566194/article/details/127568441?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168791277616782427483738%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168791277616782427483738&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127568441-null-null.142^v88^control,239^v2^insert_chatgpt&utm_term=%E9%BB%91%E9%A9%ACes6&spm=1018.2226.3001.4187



### 数组去重

```js
const newNums = nums.filter((n, i) => {
    // 其实就是取第一个值 ，i是传进来的值，indexOf的是找的值，把第一个值筛出来就去重了
    return nums.indexOf(n) === i
})
```

这样也能去重简单数组，indexOf会找元素第一次出现的索引，后面有相同的元素被遍历到时。索引也是同一个，然后就不满足条件了



对象数组不能单单使用includes

最好是用Set，数组map方法

const c = [{a: 1},{b:1},{a: 1},{b:1}]



temp = c.map(t=>JSON.stringify(t))

![image-20230830150257575](%E6%95%B4%E7%90%86.assets/image-20230830150257575.png)

const d = [...new Set(temp)]					全转成字符串了，用Set去重

![image-20230830150329278](%E6%95%B4%E7%90%86.assets/image-20230830150329278.png)

d.map(s=>JSON.parse(s))								再把它们从json形式的字符串转回来

![image-20230830150454440](%E6%95%B4%E7%90%86.assets/image-20230830150454440.png)

[(183条消息) JS数组对象使用new Set() 快速去重 - 戴向天_js new set()_戴向天的博客-CSDN博客](https://blog.csdn.net/weixin_41088946/article/details/118915409)

### var let 经典面试题





方法的作用域是单独的，等循环结束才执行？

**预解析**是在程序执行之前，会进行一遍预检。查找当前**作用域**内由 `function` 和 `var` 。并且每次更换作用域都会在此作用域中执行**预解析**

**变量提升**是指，在查找到由 `function` 和 `var` 后，首先在当前作用域的顶端定义好并赋给默认值。`var`的默认值为 `undefined`， `function`的默认值为**函数本身**

预解析和变量提升的过程中，并不会将变量赋值，而只是定义

方法优先级比var高

宏任务和微任务和循环里的方法调用顺序有什么关联吗（let面试题）

并没有，就只是变量提升

![image-20230703203656810](%E6%95%B4%E7%90%86.assets/image-20230703203656810.png)

代码意思：循环给arr赋值，在循环结束后调用让他们去找i

换成let 每个都是不同的，都有自己的块级作用域

var时，函数执行时循环已经结束了，所以i都是2，方法向上查找作用域，上级是全局左右域，

而let时，方法向上查找作用域，找到的是循环产生的块级作用域，

[彻底弄懂JavaScript作用域问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/161398465)



### 实现每隔一秒打印 1,2,3,4

```javascript
javascript复制代码// 使用闭包实现
for (var i = 0; i < 5; i++) {
  (function(i) {
    setTimeout(function() {
      console.log(i);
    }, i * 1000);
  })(i);
}
// 使用 let 块级作用域
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, i * 1000);
}
```


链接：https://juejin.cn/post/6946136940164939813



### 使用类注意事项

三个注意点：

在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象。
类里面的共有属性和方法一定要加 this 使用。
类里面的 this 指向问题。
constructor 里面的 this 指向实例对象, 方法里面的 this 指向这个方法的调用者。



### **构造函数**

- **静态成员**：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。

- **实例成员**：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。

  静态成员有啥用，就是咱们用的像Array.from的这样直接用的方法



### 原型

引入一下，为什么声明的对象变量可以用valueOf实例方法，就是因为我们这个对象通过原型链去找到了Object上的valueOf方法

它怎么去找的呢，就是通过__proto 属性指向原型对象prototype上找的

而原型链就是指__proto将对象和原型连接起来组成的这个链型的结构





**原型链**

原型链就是多个对象通过 __proto__ 的方式连接了起来

每个函数都有 prototype 属性， 除了 Function.prototype.bindO ，该属性指向原型。每个对象都有____proto____ 属性，指向了创建该对象的构造函数的原型 。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性， 我们并不能访问到，所以使用 _proto_ 来访问。

对象可以通过 __proto__ 来寻找不属于该对象的属性,_proto_ 将对象连接起来组成了原型链



对象原型 __proto__ 

构造函数原型 prototype 

就是说用 prototype 构造，然后拿____proto__ 去拿去用？就是下发和向上查找机制的区别咯？

- __proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性， 因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype。

  - ​	      console.log(ldh.__proto===Star.prototype);  true

    Star.prototype用来写、构造给下面的对象来使用

    ldh.__proto，用来看它上一级的构造函数

构造函数回去看视频

![img](%E6%95%B4%E7%90%86.assets/28b3161e66b44f808505753b5f09c9be.png)



实例与构造函数通过原型链连接了起来

### 组合继承：

三步走

call指构造函数继承属性

child原型对象指向父类（new 父类（））继承方法

子类原型对象的构造函数指回子类



核心原理：在构造函数里 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。

借用原型对象继承父类型方法

一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。 

 prototype 原型对象 = new 父类() 

把父类所有方法、原型链（构造方法）东西拿过来了，但也把自己的构造方法也变成了父类

所以要指回来    Son.prototype.constructor = Son

### ES6 类的本质

1.  class 本质还是 function。
2.  类的所有方法都定义在类的 prototype 属性上
3.  类创建的实例,里面也有 __proto__ 指向类的 prototype 原型对象





### 对象解构赋值

如果变量名与属性名不一致，必须写成下面这样。

把后面的名为foo的属性赋给了baz

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。

```javascript
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

[变量的解构赋值 - ECMAScript 6入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/destructuring)





交换变量值的技巧

有一个著名的使用结构赋值来交换两个变量的值的技巧：

let guest = "Jane";
let admin = "Pete";

// 让我们来交换变量的值：使得 guest = Pete，admin = Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane（成功交换！）

### 闭包会出现什么问题

闭包是一种函数写法,扩大成员变量的作用域

闭包是指一个函数可以访问并操作其创建时作用域中的变量，即使它已经脱离了创建时的作用域。



js中变量的**函数作用域导致我们在一个函数内部是无法访问另一个函数内部的成员变量的，但是通过闭包的写法，也就是在函数内部写另一个函数进行访问该函数内部的成员变量**的过程就是闭包

[中高级前端面试题总结第一期_前端面试题中高级_前端.火鸡的博客-CSDN博客](https://clearlove.blog.csdn.net/article/details/126422837?spm=1001.2014.3001.5502)

开发中发现荣哥常常把参数用局部变量接过来再用

闭包的优点和缺点
优点
①保护变量安全 ，实现封装，防止变量声明冲突和全局的污染
②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）
③匿名自执行函数可以减少内存消耗

缺点
①被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；
②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响







### **spread 扩展运算符**

扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，**对数组进行解包**。



**rest 参数 ：** function add(…args) 是放在函数传参

**spread：** fn(…tfboys) 是放在调用函数时

> 特性
>
> const tfboys=['AA','BB','CC']
> function chunwan(){
> console.log(arguments);
> }
> chunwan(...tfboys);  //0:'AA' 1:'BB' 2:'CC'



在解构赋值中，未被读取的可遍历的属性，分配到指定的对象**z**上面

```
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

注意：解构赋值必须是最后一个参数，否则会报错

解构赋值是浅拷贝



使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：`let cloneObj = { ...obj };`







y= 24 

z = 13

37+5

return 42





### 对象

#### 属性的简写

简写的对象方法不能用作构造函数，否则会报错



#### 属性名表达式

```ts
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```





### 生成器，遍历器生成函数

直接看面试题吧，那个最好

Generator相当于JS实现的协程

![image-20230706190556106](%E6%95%B4%E7%90%86.assets/image-20230706190556106.png)

`Generator` 函数会返回一个遍历器对象，即具有`Symbol.iterator`属性，并且返回给自己

```
function* gen(){
  // some code
}

var g = gen();

g[Symbol.iterator]() === g
// true
```

通过`yield`关键字可以暂停`generator`函数返回的遍历器对象的状态

yield把这个代码分成几段，

函数的调用只是返回了个迭代器对象，要用.next才能进去（next恢复运行），并且卡在yield位置（yield暂停运行），并且把yield表达式的值给返回回去了，放在当前的返回对象中

第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 2

![image-20230706190914523](%E6%95%B4%E7%90%86.assets/image-20230706190914523.png)

![image-20230706190932367](%E6%95%B4%E7%90%86.assets/image-20230706190932367.png)

（上面这段代码需要注意的是，最后一个yield后面也被分成了代码段，所以.next依然能进去，所以是能输出语句的，但是迭代结束了，后续没有了，所以返回了undefined）

上面是yield的表达式是赋值过去的，咱们也可以传参传进去，这个就是.next的入参

(next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值)







![image-20230706191834756](%E6%95%B4%E7%90%86.assets/image-20230706191834756.png)



问题：这里的‘2 ’是不是就是默认值呀，并不是，就是迭代器返回回去的对象{value：的值，done: }



![image-20230706192418181](%E6%95%B4%E7%90%86.assets/image-20230706192418181.png)

.return也能主动返回结果

![image-20230706192833271](%E6%95%B4%E7%90%86.assets/image-20230706192833271.png)

不过大家肯定都是在函数里面才用调用咯，这里想演示做到同一个效果，只是想表达return的值传在这个value里来了

如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true ，表示遍历已经结束。



在这引申，yield就和一个return一样，next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值







使用场景：为不具备迭代器接口的对象提供了遍历操作

为什么没有.next，因为是用for...of遍历控制的，我只想要读它的值而已，我用yield主要是想让它去做返回

**再次提醒：**next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值

![image-20230706193908366](%E6%95%B4%E7%90%86.assets/image-20230706193908366.png)

![image-20230706193853900](%E6%95%B4%E7%90%86.assets/image-20230706193853900.png)

视频里说[key,value]就相当于.next把他给取出来了









### async  

处理Promise的，读取里面真实的数据

await`命令就是内部`then`命令的语法糖

（5）Generator 函数的语法糖

（1）内置执行器

Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说， async 函数的执行，与普通函数一模一样，只要一行。

（2）更好的语义。

async 和 await ，比起星号和 yield ，语义更清楚了。 async 表示函数里有异步操作， await 表示紧跟在后面的表达式需要等待结果。

（3）更广的适用性。

（4）**返回值是 Promise。**

Generator  中  yield 返回值是 Iterator 对象，await返回值是 Promise。

`async` 函数返回一个 **`Promise`对象，可以使用 `then`方法添加回调函数**。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。







### Promise

将几种解决异步的方案进行一个比较：

回调函数

所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，再调用这个函数

`Promise`就是为了解决回调地狱而产生的，将回调函数的嵌套，改成链式调用（面试题generator里的）

（来自github）

#### 状态

`promise`对象仅有三种状态

- `pending`（进行中）
- `fulfilled`（已成功）
- `rejected`（已失败）

#### 两特点

- **对象的状态不受外界影响**，只有异步操作的结果，可以决定当前是哪一种状态
- **一旦状态改变**（从`pending`变为`fulfilled`和从`pending`变为`rejected`），**就不会再变**，任何时候都可以得到这个结果

#### 实例方法

```js
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```



- then()

`then`是实例状态发生改变时的回调函数，第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函

- catch()

`catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数

- finally()

`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作



#### 构造函数方法

`Promise`构造函数存在以下方法：

- all()

- race()

- allSettled()

- resolve()

- reject()

- try()

  #### all()		&&操作（全真才真，一假全假）

  

`Promise.all()`方法用于将多个 `Promise `实例，包装成一个新的 `Promise `实例

const p = Promise.all([p1, p2, p3]);		

接受一个数组（迭代对象）作为参数，数组成员都应为`Promise`实例



接收一个Promise数组，数组中如有非Promise项，则此项当做成功，

只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`

有一个被`rejected`，`p`的状态就变成`rejected`



```js
function promiseAll(promises) {
  return new Promise(function(resolve, reject) {
    if(!Array.isArray(promises)){
        throw new TypeError(`argument must be a array`)
    }
    var resolvedCounter = 0;
    var promiseNum = promises.length;
    var resolvedResult = [];
    for (let i = 0; i < promiseNum; i++) {
      Promise.resolve(promises[i]).then(value=>{
        resolvedCounter++;
        resolvedResult[i] = value;
        if (resolvedCounter == promiseNum) {
            //每个都执行了resolve才返回真
            return resolve(resolvedResult)
          }
      },error=>{
           //有一个没执行resolve就没返回了reject的状态
        return reject(error)
      })
    }
  })
}
// test
let p1 = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve(1)
    }, 1000)
})
let p2 = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve(2)
    }, 2000)
})
let p3 = new Promise(function (resolve, reject) {
    setTimeout(function () {
        resolve(3)
    }, 3000)
})
promiseAll([p3, p1, p2]).then(res => {
    console.log(res) // [3, 1, 2]
})

```





#### allSettled()

有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。

`**Promise.all()** `方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。 **[Promise.all（）方法](https://blog.csdn.net/qq_52855464/article/details/125376557?spm=1001.2014.3001.5502)**

[Promise.allSettled（）方法介绍_潮汐未见潮落的博客-CSDN博客](https://blog.csdn.net/qq_52855464/article/details/125407602)



# TS

## 函数返回值和传参类型规定

```ts
function returnItem (param: string): string {
  return param
}

```

## 泛型

```ts
那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值。
这个类型变量在 TypeScript 中就叫做「泛型」。

function returnItem<T>(param: T): T {
  return param
}

```

我们在函数名称后面声明泛型变量 `<T>`，它用于捕获开发者传入的参数类型（比如说string），然后我们就可以使用`T`(也就是string)做参数类型和返回值类型了。



[TypeScript入门之泛型 - 掘金 (juejin.cn)](https://juejin.cn/post/7109280052566556680)





```javascript
// 这能看懂吧？
// 标记 arg 是个 number 类型
// 标记 foo 返回值是个 string 类型
function foo(arg: number): string;

// 加上泛型，跟上面没区别
function foo<T>(arg: number): string;

// 改变一下 arg 的类型和 foo 的返回值类型
// 这里意思即为 foo 的返回值和 arg 的返回值类型永远相同
// 你传 foo(number) 进来，返回值就也是 number
// 你传 foo(string) 进来，返回值就也是 string
function foo<T>(arg: T): T;

```

冒号后面的`T`代表该函数返回的类型

函数的`<>`中的`T`是泛型声明：即有一个类型叫`T`，在后面可以用`T`指代这个还不知道的类型。

[javascript - ts 泛型 后面的那个冒号是干嘛的？ - SegmentFault 思否](https://segmentfault.com/q/1010000040694522)



## type和interface的区别

关键字`type`是声明类型别名的关键字。它的语法如下：

```typescript
type AliasName = Type;
1
```

- type：声明类型别名的关键字
- AliasName：类型别名的名称
- Type：类型别名关联的具体类型

两者放的地方是一样的

#### 不同点

type 在声明类型别名之后实际上是一个赋值操作，它需要将别名与类型关联起来。也就是说类型别名不会创建出一种新的类型，它只是给已有类型命名并直接进行引用。interface是定义了一个接口类型。
type 能够表示非对象类型， 而 interface 则只能表示对象类型。
interface可以继承其他的接口、类等对象类型， type 不支持继承。

#### 相同点

- 都可以用来定义 **对象** 或者 **函数** 的结构，而严谨的来说，type 是引用，而 `interface`是定义。



[TS篇—type 和 interface 的区别_ts中type和interface的区别_小和尚同志的博客-CSDN博客](https://blog.csdn.net/qq_42345237/article/details/124895617#:~:text=type 在声明类型别名之后 实际上是一个赋值操作，它需要将别名与类型关联起来 。 也就是说类型别名不会创建出一种新的类型，它只是给已有类型命名并直接进行引用。 interface 是 定义了一个接口类型。,则 只能表示对象类型 。 interface 可以 继承其他的接口、类等对象类型， type 不支持继承。)





## 装饰器	vue-property-decorator

让Vue2支持ts的秘诀

### @Ref

 @Ref("button") readonly button:any;

button 参数是只读的，类型是any



**普通的ref只能获取与元素，不能直接链式调用获取里面的方法**



**具名元素**

- `@Ref('refInTemplate') readonly xxxxElement!: ElementType`: 此时页面上需要有一个`ref=refInTemplate`的元素,把模板上 `ref="refInTemplate"`的元素赋给 `this.xxxxElement`

#### 项目中的使用



```js
  <el-form
          :model="form"
          :rules="rules"
          label-position="top"
          ref="FormRef"
          label-width="100px"
          class="dynamic-form"
        >
```



export default class Dynamic extends Vue {

 // 这么用了之后，就是可以使用this.FormRef了

 @Ref() FormRef!: any

##### 使用：

```js
  handleRelease () {
    // 任一表单项被校验后触发
    this.FormRef.validate().then((valid: boolean) => {
```



# VUE

二、什么是Model
我们经常见到“Model”，如MVC模式中的M就是指“Model”，MVVM中的“Model-View-ViewModel”，数据库抽象层中的“Model”等。那么什么是model呢？

通常，Model有如下几种用法：

等价于Entity，完全不具备其他业务逻辑代码。

当成数据库接口层，就是将数据库的读写、增删、查改都封装在Model中，经常出现“getUserById”这样的写法。

当成纯粹的业务逻辑类。

Model是模型，而不是“数据”，Model应该是利用Entity实体，来组合、处理、整合更上层、更抽象数据的类。是基于Entity的更高层的数据抽象与处理。
————————————————
版权声明：本文为CSDN博主「m1m-FG」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/SakuraMG/article/details/128652284





------

**使用Transition内置组件及CSS transition完成动画**

[Transition | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/built-ins/transition.html#the-transition-component)

------





#### 创建vue3 项目

![image-20230706103915851](%E6%95%B4%E7%90%86.assets/image-20230706103915851.png)



###  v-if和v-show的区别

- **手段**：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；

- **编译过程**：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；

- **编译条件**：**v-if是惰性的，如果初始条件为假，则什么也不做(就没有dom元素了)**；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；

- **性能消耗**：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；

- **使用场景**：v-if适合运营条件不大可能改变；v-show适合频繁切换。

  链接：https://juejin.cn/post/6919373017218809864
  

## v-model是如何实现的

**（1）作用在表单元素上** 

**动态绑定了 input 的 value 指向了 messgae 变量**（感觉可以和el里的input串起来 了），并且在触发 input 事件的时候去动态把 message设置为目标值：

```javascript
javascript复制代码<input v-model="sth" />
//  等同于
<input 
    v-bind:value="message" 
    v-on:input="message=$event.target.value"
>
//$event 指代当前触发的事件对象;
//$event.target 指代当前触发的事件对象的dom;
//$event.target.value 就是当前dom的value值;
//在@input方法中，value => sth;
//在:value中,sth => value;
```


链接：https://juejin.cn/post/6919373017218809864





## .sync 修饰符

没搞懂和v-on="$listeners"、v-bind=“$attrs有什么区别，（这个需要传出来的，那个就是将属性和事件父传孙）

在对一个 prop 进行“双向绑定,单向修改”的场景下--好像项目里也不是这个场景，因为子组件不能直接修改父组件，sync在2.3版本引入，作为一个事件绑定语法糖，利用[EventBus]，当子组件触发事件时，父组件会响应事件并实现数据更新，避免了子组件直接修改父组件传过来的内容。

.sync是一个语法糖。是父组件监听子组件更新某个props的请求的缩写语法

就是省写了$emit和父组件中回调函数，达到直接修改数据，荣哥说就当隔组件使用v-model，特别注意prop写法

```text
:money.sync="tatol"//等价
:money="total" v-on:update:money="total=$event"
```

$attrs---它是组件自身的一个属性，可以获取到传递给组件的所有没有用props声明接收的prop属性，除了class、style属性

提醒：prop 传递的属性不会被接收。父组件用prop接收了一些数据，那在子里面就不会$attr接收这些数据

prop 就想当于吃流水席，把自己想要的东西截下来了？



**项目中我的理解**：我需要在eltable里的table和table-column其实是父子关系封装的，但在我只是用eltable ，我不关心内部，只传东西给eltable，这个时候就需要在调用table-colum时写

<el-table-column v-if="showCheckbox" type="selection" v-bind="$attrs" v-on="$listeners"

让这个子组件接受父组件同样的东西，使得table，table-colum看起来是同层次的东西

[(181条消息) Vue中 $attrs、$listeners 详解及使用_明天也要努力的博客-CSDN博客](https://blog.csdn.net/ZYS10000/article/details/116017711)

[Vue：深入理解 Vue 的 .sync 修饰符 - 掘金 (juejin.cn)](https://juejin.cn/post/6977022803744653320)



## v-on="$listeners"、v-bind=“$attrs部分

总结在management页面里了

没用slot插槽占位符占位的slot也会存在$attr里，这东西像是一个捡漏的东西，你不要的东西就都给我吧，（起码东西没丢掉）

prop也一样



## 三个插槽

（＜slot＞、v-slot、slot-scope）

```
 <template #operate="{scope}">
具名插槽写法（并不是吧就是作用域插槽，具名插槽子组件里写的是name，这里写的slot-scope，而且这个有参数，作用域插槽就是带参传递插槽）
```

![image-20230628201108475](%E6%95%B4%E7%90%86.assets/image-20230628201108475.png)



 slot-scope="scope"

v-slot缩写成#

作用域插槽

games数据在Category（子）组件中，但使用数据所遍历出来的结构由App（父）组件决定）

插槽有点混，

<slot name=''>   ==    <template v-slot:' '>

按照插槽类型来那个叫operate



绑定在 `<slot>` 元素上的 attribute 被称为**插槽 prop**。现在在父级作用域中，我们可以使用带值的 `slot-scope` 来定义我们提供的插槽 prop 的名字：

 







#### 

```
  <template #operate="{scope}">
```

还是不知道这个到底是传的啥，{scope}代表什么

我理解好像还是有点偏差，作用域插槽是可以和具体插槽一起用吗

带{}就是吧它当js处理吧，但是我怎么没有看到scope方法？

上面的都是错误的理解

描述：作用域插槽其实就是带数据的插槽，即带参数的插槽（所以你能具名后，后面有参数的写法了吧   <template v-slot:header="scope">），简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内

```
   <template #operate="{scope}">
          <el-button @click.native.stop="handleAudit(scope.row)" type="text">审核</el-button>
        </template>
```





v-slot
在vue2.6中。上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
子组件用法保持不变，父组件中
slot属性弃用，具名插槽通过指令参数v-slot:插槽名的形式传入，可以简化为#插槽名
slot-scope属性弃用，作用域插槽通过v-slot:xxx="slotProps"的slotProps来获取子组件传出的属性
v-slot属性只能在template上使用，但在只有默认插槽时可以在组件标签上使用
————————————————
版权声明：本文为CSDN博主「别来打扰我」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_44166697/article/details/108274625
————————————————



```
    <!--  slot-scope 作用域插槽中的父组件使用数据 -->
        <!--子部件这个部分的数据传过来了  <slot v-else-if="col.slotName" :name="col.slotName" :scope="scope" /> -->
          <span v-if="item.slotName" :slot="item.slotName" slot-scope="{ scope }">
            <!-- 然后又把它传出去了，传了个name和scope -->
            <slot :name="item.slotName" :scope="scope"></slot>
          </span>
```

传到这了：

```
<template #operate="{scope}">
          <el-button @click.native.stop="handleAudit(scope.row)" type="text">审核</el-button>
        </template>
```

然后传到里面默认插槽里

也就是这里

```
  <slot :name="item.slotName" :scope="scope"></slot>
```

逻辑好怪，传数据进子组件里，用作用域插槽把子组件里的数据又取出来了，然后又用默认插槽放到子组件里去



 <template #operate="{scope}">



这里又用的新写法，其他地方用的老写法

## $emit与eventbus

父组件绑定自定义组件

```vue
//父组件中		这就叫绑定事件
	<Student @atguigu="getStudentName"/> 
```

```js
//子组件,调用的方法里再用$emit调用
	this.$emit('atguigu',this.name,666,888,900)
```

父组件还可以这样绑定自定义事件

this.$refs.xxx.$on()

**解绑自定义事件**

this.$off('atguigu')



eventBus（全局事件总线）就是

就是把绑定事件这个动作收集到同一个地方去呗

就是把放到了一个很高的地方里收集绑定事件呗

可以放到一个ts里引入用，也可以挂到vm实例链上

```js
new Vue({
	......
	beforeCreate() {
		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
	},
    ......
}) 
```





## $set、$forceUpdate() 、$nextTick

### $forceUpdate

[vue强制更新视图 $forceUpdate() - 掘金 (juejin.cn)](https://juejin.cn/post/6973830848529301534)

迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。



### $nextTick

vue 更新 DOM这个流程 是异步更新的，数据变化，DOM 的更新不会马上完成，

而你要写的方法，它是依赖新的数据，新的DOM结构的时候就可以nextTick，它的作用就是在下次 DOM 更新循环结束之后执行的传进来的延迟回调。

nextTick 的回调是在下次 DOM 更新循环结束之后执行的传进来的延迟回调。

实现原理：nextTick 主要使用了宏任务和微任务。根据执行环境分别尝试采用

- Promise：可以将函数延迟到当前函数调用栈最末端
- MutationObserver ：是 H5 新加的一个功能，其功能是监听 DOM 节点的变动，在所有 DOM 变动完成后，执行回调函数
- setImmediate：用于中断长时间运行的操作，并在浏览器完成其他操作（如事件和显示更新）后立即运行回调函数
- 如果以上都不行则采用 setTimeout 把函数延迟到 DOM 更新之后再使用，原因是宏任务消耗大于微任务，优先使用微任务，最后使用消耗最大的宏任务



将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 `Vue.nextTick` 一样，不同的是回调的 `this` 自动绑定到调用它的实例上。



[2023高频前端面试题合集之Vue（上篇） - 掘金 (juejin.cn)](https://juejin.cn/post/7208005892313579576#heading-9)



## @Provide()、@Inject()依赖注入

[依赖注入 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/components/provide-inject.html#inject)

实现祖与后代通信

只要实现上下游就行，Provide发，Inject收

projectDetailPage：

```js
export default class projectDetailPage extends Vue {

 @() OPHandle: projectDetailPage = this
```

TreeFile2

```js
export default class TreeFile2 extends Vue {
  @Inject() OPHandle!: Handle | any
```

##### `props`和`$ref`和`$children`和`provide/inject`的主要区别：

- props 侧重于数据的传递，并不能获取子组件里的属性和方法，适用于自定义内容的使用场景
- $ref 侧重于获取子组件里的属性和方法，并不是太适合传递数据，并且 ref 常用于获取dom元素，起到选择器的作用
- $children 侧重于获取所有的直接子组件，得到的是一个无序的数组，并不太适合向多个子组件传递数据
- provide/inject 侧重于在开发高阶插件/组件库时使用，并不推荐用于普通应用程序代码中



- provide 和 inject的绑定并**不是可响应**的，这是刻意为之的。但是，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的；

- 如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像`Vuex`这样真正的状态管理方案了。

  耦合起来了，重构困难，所以一般是用在高级插件开发中咯

  [Vue组件之间的传值 - 掘金 (juejin.cn)](https://juejin.cn/post/6904536680183791623#heading-10)













## 生命周期

created 	组件再内存中创建完毕后 	发ajax请求初始数据



mounted  	 虚拟Dom已经被挂载到真实Dom上，此时我们可以获取Dom节点，`$ref`在此时也是可以访问的。

> 我们在此时可以去获取节点信息，做Ajax请求，对节点做一些操作



**vue异步请求适合放在created里面，如涉及到需要页面加载完成之后的操作就放在mounted里面**



之前怕watch监听器监听不到props啥的，就去找了点vue挂载实例看的

在initState()做了这些事情：

// 初始化组件的watcher列表
  vm._watchers = []
  const opts = vm.$options

if (opts.props) initProps(vm, opts.props)//初始化Props
if (opts.methods) initMethods(vm, opts.methods)//初始化methods
if (opts.data) {
  initData(vm)} else {
  observe(vm._data = {}, true /* asRootData */)}//初始化data
if (opts.computed) initComputed(vm, opts.computed)//初始化computed

4.所以Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的。





## vue2响应式原理

响应式是什么呢：响应式是数据变化时自动更新视图

通过观察者模式结合数据劫持，在读取数据时进行依赖收集，在数据变化时自动触发视图更新



data里面的数据会通过 Object.defineProperty方法加工，给数据添加getter和setter，

Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，给数据添加getter和settet，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)，如果属性发生变化会通知相关依赖进行更新操作(发布订阅)。

就将这样加工后的对象传给vm实例的_data属性，



这样之后，data里的数据发生变化就会调用set方法，然后重新渲染vue模板，就达到响应式的效果了



讲一下解析模板后面的操作—》调用 set 方法时，就会去解析模板----->生成新的虚拟 DOM----->新旧DOM 对比 -----> 更新页面



所谓响应式就是首先建立响应式数据和依赖之间的关系，当这些响应式数据发生变化的时候，可以通知那些绑定这些数据的依赖进行相关操作，可以是 DOM 更新，也可以是执行一个回调函数。

感觉这里对依赖的解释挺好的



Vue2 通过 Object.defineProperty 将对象的属性转换成 getter/setter 的形式来进行监听它们的变化，当读取属性值的时候会触发 getter 进行依赖收集，当设置对象属性值的时候会触发 setter 进行向相关依赖发送通知，从而进行相关操作。

由于 Object.defineProperty 只对属性 key 进行监听，无法对引用对象进行监听，所以在 Vue2 中创建一个了 Observer 类对整个对象的依赖进行管理，当对响应式对象进行新增或者删除则由响应式对象中的 dep 通知相关依赖进行更新操作。

Object.defineProperty 也可以实现对数组的监听的，但因为性能的原因 Vue2 放弃了这种方案，改由重写数组原型对象上的 7 个能操作数组内容的变更的方法，从而实现对数组的响应式监听。

[2023高频前端面试题合集之Vue（上篇） - 掘金 (juejin.cn)](https://juejin.cn/post/7208005892313579576#heading-5)

[面试官的步步紧逼：Vue2 和 Vue3 的响应式原理比对 - 掘金 (juejin.cn)](https://juejin.cn/post/7124351370521477128?searchId=2023110816413458E71716FB6044C392D0)

对象的话

Vue 添加或移除对象里的属性是无法监测到的，先让`data` 对象上存在才能让 Vue 将它转换为响应式的，所以用$set向响应式对象中添加一个响应式`property`

监测数组又不一样，

通过重写数组方法，调用方法后，重新解析模板，进而更新页面







## 双向数据绑定

Vue 的数据双向绑定整合了 Observer，Compile 和 Watcher 三者，

通过 Observer 来监听自己的 model 的数据变化，

通过 Compile 来解析编译模板指令，

最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，

达到数据变化->视图更新，视图交互变化（例如 input 操作）->数据 model 变更的双向绑定效果。


链接：https://juejin.cn/post/7208005892313579576

##  Vue 子组件和父组件执行顺序

**加载渲染过程：**

1. 父组件 beforeCreate
2. 父组件 created
3. 父组件 beforeMount      
4. ​    子组件 beforeCreate
5. ​    子组件 created
6. ​    子组件 beforeMount
7. ​    子组件 mounted
8. 父组件 mounted

父组件在beforeMount里遇到子组件就会开始子组件，直到子组件mouted再回来

作者：CUGGZ
链接：https://juejin.cn/post/6919373017218809864
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 体会	:class 和:style的区别

Class 与 Style 绑定 | Vue.js (vuejs.org)



之前有点区分不开：class的对象使用（现在还是不明白，怎么有些用了‘ ’，有些没用）



我们可以给 :class 绑定一个数组来渲染多个 CSS class：



data() {

  return {

​    activeClass: 'active',

​    errorClass: 'text-danger'

  }

}

template



<div :class="[activeClass, errorClass]"></div>

:style 支持绑定 JavaScript 对象值，对应的是 HTML 元素的 style 属性：



data() {

  return {

​    activeColor: 'red',

​    fontSize: 30

  }

}

template





## vue加监听器，不仅可以用watch去监听，

 还可以直接加window.addEventListener('load', this.refresh, false);  （在beforeDestory里销毁）





##  $xxTab: Tab

和

```js
 tabInstance.open(getModuleName('office'), '通知详情', { ...options, messageVo: res })

export const tabInstance = new Tab()


```



 this.$xxTab.open('office', '文件打印', { resource: `?file=${url}`, params: data, current })

和	this.$xxTab.getArgs()里请求参数形成闭环





## 过滤器

- 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
- 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = “xxx | 过滤器名”

单斜杠 |



```vue
<li>商品价格：{{item.price | filterPrice}}</li>

 filters: {
    filterPrice (price) {
      return price ? ('￥' + price) : '--'
    }
  }

```

链接：https://juejin.cn/post/6919373017218809864



​	



## 异步事件返回

![image-20231107111138797](%E6%95%B4%E7%90%86.assets/image-20231107111138797.png)

子组件中可以这么返回了

（因为await就是处理Promise返回的吧）

![image-20231107111152884](%E6%95%B4%E7%90%86.assets/image-20231107111152884.png)





## is属性

**预期**：`string | Object (组件的选项对象)`

用于[动态组件](https://v2.cn.vuejs.org/v2/guide/components.html#动态组件)且基于 [DOM 内模板的限制](https://v2.cn.vuejs.org/v2/guide/components.html#解析-DOM-模板时的注意事项)来工作。

示例：

```vue
<!-- 当 `currentView` 改变时，组件也跟着改变 -->
<component v-bind:is="currentView"></component>
<!-- 这样做是有必要的，因为 `<my-row>` 放在一个 --><!-- `<table>` 内可能无效且被放置到外面 -->
<table>  <tr is="my-row"></tr></table>
```

# Vue3与小程序

在8_14里

# axios

**那个导出的配置项，写的特别好特别全，如果搞透了，我考，面试axios二次封装随便问**

axios的使用和二次封装的一些实例，请求配置、默认配置项、自定义配置项

const request = axios.create({ timeout: 60000 })

开始写自定义配置项

自定义配置，写个request ，export 出来

统一放到一个地方管理

```js
import {request} from "@/utils/request";
import {cookies} from "@/utils/cookies";
```



```js
// 上面两个类已经排查完了，先在这个文件中声明，方便后面的使用
export {request, cookies}

```

在外面引入 request方法后直接 return用

```js
export const getExport = (url: string, params: Object, fileName = '') => {
 return request({
  url: url,
  params: params,
  method: 'get',
  responseType: 'blob',
  baseURL: baseUrl
 }).then((res: any) => {
```



文件预览中

```js
  // 申报材料
 async initDeclareTreeData() {
	const { data }: any = await fetch.get('/xiangmu/prj/box/declareTree', {
      projectCode: this.subParams.projectCode
    })
```

fetch.ts中封装的get方法

```js
export const get = (url: string, params: Object) => {
  return request({
    url: url,
    params: params,
    method: 'get',
    baseURL: baseUrl
  })
}
```





- [ ] Request.ts的导出请求

可以结合项目看，重点请求拦截和响应拦截，检测权限（是否登录）

- [ ] fetch.ts 


```js
export const getExport = (url: string, params: Object, fileName = '') => {
  return request({
    url: url,
    params: params,
    method: 'get',
    responseType: 'blob',
    baseURL: baseUrl
  }).then((res: any) => {
  //主要是这一块
    const blob = new Blob([res.data], {type: res.headers['content-type']})
    const link = document.createElement('a')
    link.href = window.URL.createObjectURL(blob)
    link.download = fileName ? fileName + '.xlsx' : decodeURI(res.headers['content-disposition'].split('=')[1])
    link.click()
    window.URL.revokeObjectURL(link.href)
    
  })
}
```





有封装拦截器联想到权限管理，这些就属于接口权限

路由守卫就是路由权限



还有菜单权限、按钮权限



[TypeScript实战之用TS封装Axios - 掘金 (juejin.cn)](https://juejin.cn/post/7113475007598034951?searchId=202308111708457DF3B53886CEC20788F3)









·············

#### paramsSerializer 序列化



paramsSerializer

序列化自定义参数，用qs库

[axios请求传参自定义paramsSerializer序列化_axios paramsserializer_码大星的博客-CSDN博客](https://blog.csdn.net/hututu3/article/details/123222938)

[npm 中 qs库的介绍与使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7125723650627469319#heading-4)

```js
 config.paramsSerializer = function (params) {
        return QS.stringify(params, { arrayFormat: 'repeat' }
```







[axios请求传参自定义paramsSerializer序列化_axios paramsserializer_码大星的博客-CSDN博客](https://blog.csdn.net/hututu3/article/details/123222938)



[npm 中 qs库的介绍与使用 - 掘金 (juejin.cn)](https://juejin.cn/post/7125723650627469319#heading-4)



[TypeScript实战之用TS封装Axios - 掘金 (juejin.cn)](https://juejin.cn/post/7113475007598034951?searchId=202308111708457DF3B53886CEC20788F3)

### axios拦截器

utils/request.ts

这不就放到请求头里了

  **config.headers['Authorization'] =authorization**

```js
// request拦截器
request.interceptors.request.use(

  (config) => {
    // 注意 获取的token是从cookies中，表单设计器中是存储在session中

    setToast()
    const onlineAuth = cookies.getToken()
    const authorization = onlineAuth ? `Bearer ${onlineAuth}` : auth;
    config.headers['Authorization'] = authorization
    if (config.method === 'get') {
      config.paramsSerializer = function (params) {
        return QS.stringify(params, { arrayFormat: 'repeat' })
      }
    }
    return config
  },
  (error) => {
    Promise.reject(error)
  }
)

```







# vue-router

怎么实现：

引入过来用然后创建路由规则数组去生成路由对象，注入new实例中

声明式：

router-link来替代a标签,点击跳转，然后在router-view处显示

to=/path?参数名=值

例：`to="/part?name=小明"`

```
<template>
  <div>
    <div class="footer_wrap">
      <router-link to="/find">发现音乐</router-link>
      <router-link to="/my">我的音乐</router-link>
      <router-link to="/part">朋友</router-link>
    </div>
    <div class="top">
      <router-view></router-view>
    </div>
  </div>
</template>
//在控制台元素检查时会发现激活的类名 在样式style中定义高亮样式 点击时就会高亮

```



[vue中实现路由跳转的三种方式（超详细整理）_vue路由跳转_殿君不是殿军的博客-CSDN博客](https://blog.csdn.net/qq_43375584/article/details/125242665)







this.$router.push({ name:‘hello’, query:{ name:‘word’, age:‘11’ } })

携带参数传过去，再this.$route.query.参数	去使用

### `$route`和`$router`的区别

> - $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
> - $router是“路由实例”对象包括了路由的跳转方法，钩子函数等。



### 路由跳转方式name 、 path 和传参方式params 、query的区别（重要）

path 和 name路由跳转方式，都可以用query传参

![img](%E6%95%B4%E7%90%86.assets/7872f464b54aae0d00bc50b2e0f4d89c.png)

- 使用path方式跳转路由 path会忽略params 所以path不能和params一起使用
- 推荐使用name+query实现路由跳转

（query就是直接拼接在url里）

name只能+params

两个p不能同时出现





##### Vue-router的封装思想和使用:

- 全在App_main.ts里（入口文件而已）

routerMain在这里引入和app里使用，使得// routerMain 相当于 this.$router  路由对象

从这里看进routerMain的index：

路由对象在这new、导出；汇总在这引入写的其他小模块的路由文件

```
const routerMain = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: routeAll
})

export { routeAll, routeName2PathMap, routerMain }
export default routerMain

```



- 路由传参

- 路由守卫：src\router\filter\routerFilter.ts    记录下常规用法，在这里对我说，我想在vue中这里，该怎么做

  `routerMain.beforeEach(async (to: Route, _: Route, nextStep: any) => {`

   `console.log(to.path,'to.path====>>>>>')`

   `if(to.path.startsWith('/sub/subSystem-xyna') ){`

    `document.title = '长沙市信用农安智慧监管平台'`

   `}`

   `if(to.path.startsWith('/sub/subSystem-cloud') ){`

    `document.title = '智慧农业农村云上资料库'`

   `}`





## query和params传参的区别

<details open=""> <summary>参考答案</summary>
<ul>
<li><strong>query传递参数</strong>
<code>query</code>传递参数不会出现参数丢失的情况，不需要做其他配置，缺点就是参数会拼接到url后面：url?xx==yy这种方式来传递，会暴露参数，并且url也有字符长度的限制。</li>
</ul>
<p>使用方式: <code>this.$router.push({path: 'path', query: {id:1}})</code><br>
获取参数: <code>this.$route.query.id</code>获取key为id的路由参数</p>
<ul>
<li><strong>params传递参数</strong>
params传递参数是将参数放在<code>route</code>对象中，没有放在url后面，但是在跳转之后的页面刷新时，会导致当前路由中保存的params的参数丢失。</li>
</ul>
<p>使用方式：<code>this.$router.push({name: 'name', params:{id:1}})</code><br>
获取参数: <code>this.$route.params.id</code>&nbsp;获取route对象中的Params的参数信息</p></details>




链接：https://juejin.cn/post/6998324288465928205







## 组件缓存



面试题里单纯从使用出发：

那就是放在路由的meta里

有时，你可能希望将任意信息附加到路由上，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的`meta`属性来实现，并且它可以在路由地址和导航守卫上都被访问到



使用：就当组件路由的一个属性用

[路由元信息 | Vue Router (vuejs.org)](https://router.vuejs.org/zh/guide/advanced/meta.html)





[vue+typescript+router监听路由变化 - 简书 (jianshu.com)](https://www.jianshu.com/p/d41a689647a2)

缓存后如何获取数据

- beforeRouteEnter
- actived



项目里面就是把组件缓存的白名单用vuex存起来，然后再通过生命周期操作数据

beforeRouteLeave，beforeRouteEnter，actived，deactivated



业务内容

点击了其他页面，再离开该页面时通过vuex把页面放进白名单，把页面进行缓存，这样回来之前的东西就都在了



```js
  beforeRouteLeave (to: any, from: any, next: any) {
    if (to.path !== '/supervise/chooseUnit') {
      AppModule.REMOVE_KEEP_ALIVE_PAGES('addRecord')
    }
    next()
  }
//然后把另个页面获取的数据也存vuex里，回来在钩子里取出来

回来的时候取数据
  activated () {
    const formData: any = SuperviseModule.formData
    this.formData = { ...this.formData, ...formData }
  }
```



设置了 keep-alive 缓存的组件，会多出两个生命周期钩子（`activated`与`deactivated`）：

- 首次进入组件时：`beforeRouteEnter` > `beforeCreate` > `created`> `mounted` > `activated` > ... ... > `beforeRouteLeave` > `deactivated`
- 再次进入组件时：`beforeRouteEnter` >`activated` > ... ... > `beforeRouteLeave` > `deactivated`





## 路由守卫

来自8_11

hash和history的区别

hash: “#”,不会导致浏览器向服务器发出请求,监听 hashchange ,hash 可以支持低版本浏览器和 IE

history :history要处理，H5 标准发布的两个 API，pushState 和 replaceState



全局路由、组件路由等，都去看看

是不是也就是写生命周期函数？

### to、from、next三个参数的使用

to、from拿到的都是整个路由对象

```js
长这样
	name: '选择巡检单位',
    meta: {…}, 
    path: '/supervise/chooseUnit',
    hash: '', 
    query: {…},
```





```js
next({ name: 'Login' })
```

next就是个方法，应该是可选的去看看尚硅谷

```js
ƒ (to) {
        if (to === false) {
          // next(false) -> abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(createNavigationAbortedError(current, route));
  …
```





#### 路由守卫：

全局守卫、独享守卫、组件内守卫

全局

beforeEach		afterEach

独享守卫:

> 就是在 routes 子路由内写守卫

beforeEnter，

组件

beforeRouteEnter  beforeRouteLeave 

```js
beforeRouteLeave (to: any, from: any, next: any) {
    if (to.path === '/declare/index') {
      AppModule.REMOVE_KEEP_ALIVE_PAGES('superviseForVillages')
    }
    next()
  }
```





​	组件缓存在superviseForVillates里，存在了appmoudle里，看那个befor钩子

include 什么的 在App.vue里

```vue
<template>
  <div id="app" class="theme-default theme-standardFontSize theme-systemFontWeight">
    <transition name="fade">
      <keep-alive :include="keepAlivePages">
        <router-view />
      </keep-alive>
    </transition>
    <!-- <back-top :key="backTopKey"> </back-top>.list-box .van-list -->
  </div>
</template>


  get keepAlivePages() {
    return AppModule.keepAlivePages
  }
```





# Vuex

**页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。 mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中 通过mapGetter来动态获取state中的值**





### map（学名叫映射 ）

我想要在项目里简写省略this.$store.state，官方教你偷懒，不用亲自去写计算属性，

...mapState 的意思就是把mapState的参数给解开放进computed里，经过下面这样就可以直接在组件用sum、school等了

```js
	computed:{		
			// 借助mapState生成计算属性（数组写法）
			// ...mapState(['sum','school','name']),
			// 借助mapState生成计算属性（对象写法）
			...mapState({sum:'sum',school:'school',name:'name'}),

			...mapGetters(['bigSum'])
		}
https://blog.csdn.net/qq_55593227/article/details/119717498
```





### 模块化+命名空间

需要使用命名空间，这样在组件中使用的时候才认modules: {
    	countAbout,
    	personAbout
  	}

里的名字

```js
const countAbout = {
	namespaced:true,//开启命名空间
	state:{x:1},
    mutations: { ... },
    actions: { ... },
  	getters: {
    	bigSum(state){
       		return state.sum * 10
    	}
  	}
}

const personAbout = {
  	namespaced:true,//开启命名空间
  	state:{ ... },
  	mutations: { ... },
  	actions: { ... }
}

const store = new Vuex.Store({
  	modules: {
    	countAbout,
    	personAbout
  	}
})

```

开启命名空间后在组件里的使用,在之前的参数前面又多了参数，写modules里的对应的名字，这样它就知道去哪个里面找了

```js
//方式一：自己直接读取
this.$store.state.personAbout.list
//方式二：借助mapState读取：
...mapState('countAbout',['sum','school','subject']),
```

其余也差不多

```js
开启命名空间后，组件中调用dispatch

//方式一：自己直接dispatch
this.$store.dispatch('personAbout/addPersonWang',person)
//方式二：借助mapActions：
...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
```







# E-charts

[PPChart - 让图表更简单](http://ppchart.com/#/)





## 折线图

### 折线的圆点样式

[Echarts symbol 标记的图形 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/376831728)

   series: [



​    {

​     name: '巡查次数',

​     type: 'line',circle

​     barWidth: 12,

​     barGap: '80%',

​     **symbol: 'pin',**

​     **symbolSize: [2, 2],**



## 流程

给宽高

```js
          <div class="chart-canvas" ref="xpPieChartRef"></div>
```



```js
  @Ref() xpPieChartRef!: any
```



**this.xPPieChartOneChart = echarts.init(this.xpPieChartRef)**

**this.xPPieChartOneChart.setOption(option)**

```js
 
  private xPPieChartOneChart: any = null
initXpPer () {
    this.xPPieChartOneChart = echarts.init(this.xpPieChartRef)
    const map: any = {
      立案处理: 486,
      移交管辖权机关: 735,
      移交司法: 580,
      其他: 484
    }
    let total = 0
    for (const mapKey in map) {
      total += map[mapKey]
    }

    const option = {
      title: {
        textAlign: 'center',
        left: '30%',
        top: '40%',
        text: '总计',
        textStyle: {
          color: '#4E5969',
          align: 'center',
          fontSize: 16
        },
        subtext: `{a|${total}}次`,
        subtextStyle: {
          rich: {
            normal: {
              textAlign: 'center'
            },
            a: {
              align: 'center',
              fontSize: 18,
              color: '#1D2129'
            }
          }
        }
      },
      tooltip: {
        trigger: 'item'
      },
      legend: [
        {
          data: ['立案处理', '移交管辖权机关', '移交司法', '其他'],
          left: '48%',
          width: '65%',
          height: '100%',
          orient: 'vertical',
          top: 'middle',
          backgroundColor: '#f6f8fa',
          // padding: [10, 20, 10, 10],
          right: 20,
          icon: 'circle',
          formatter: (name: any) => {
            return [
              // `{a|${((map[name] / total) * 100).toFixed(2)}%}`,
              ` {a|${name}}  {b|${map[name]}}公顷   {c|${((map[name] / total) * 100).toFixed(2)}%}    `
            ].join('\n')
          },
          textStyle: {
            rich: {
              a: {
                color: '#4e5969',
                fontSize: '12px'
              },
              b: {
                color: ' #1d2129',
                fontSize: '14px'
              },
              c: {}
            }
          }
        }
      ],
      series: [
        {
          type: 'pie',
          center: ['30%', '50%'],
          radius: ['45%', '70%'],
          avoidLabelOverlap: false,
          label: {
            normal: {
              show: false,
              position: 'inside',
              formatter: '{d}%'
            }
          },
          itemStyle: {
            borderRadius: 10,
            borderColor: '#fff',
            borderWidth: 1
          },
          color: ['#2fa8fa', '#00c362', '#fecd39', '#01c2c1', '#34C9C6', '#5CD117', '#EC8E48'],
          emphasis: {
            label: {
              show: false,
              fontSize: '20',
              fontWeight: 'bold'
            }
          },
          labelLine: {
            show: false
          },
          data: [
            { value: 486, name: '立案处理' },
            { value: 735, name: '移交管辖权机关' },
            { value: 580, name: '移交司法' },
            { value: 484, name: '其他' }
          ]
        }
      ]
    }
    this.xPPieChartOneChart.setOption(option)
  }
```

```js
moutend中加载		this.initXpPer()
```





[ECHARTS学习之dataZoom组件详解_拜水:问道的博客-CSDN博客](https://blog.csdn.net/qq_44610701/article/details/121394969)

[echarts的dataZoom详解及用法 - 简书 (jianshu.com)](https://www.jianshu.com/p/da5f4a4d92ae)



## yAxis

```js
          axisLabel: {
            align: 'left',
            padding: [-100, 0, 0, 8],
            // verticalAlign: 'top',
            textStyle: {
              color: '#4E5969',
              fontSize: '12'
            }
          },
```

靠padding去调y轴文本位置吧





# Element-UI

### 样式

样式穿透::v-deep



用el-*简便样式

el-flex

 el-flex-item-center

aligin-item：center





### el-row

  <!--<el-row是布局  :gutter="20" 分栏间隔 -->



### el-form

```
      <el-form
          :model="form"
          :rules="rules"
          label-position="top"
          ref="FormRef"
          label-width="100px"
          class="dynamic-form"
        >
```



Form 组件提供了表单验证的功能，只需要通过 `rules` 属性传入约定的验证规则，并将 Form-Item 的 `prop` 属性设置为需校验的字段名即可。(**prop值需要和绑定的值同名！！！**不要再犯错误了)

```
 private rules = {
    title: [{ required: true, message: '请输入', trigger: 'blur' }],
    tagIds: [{ required: true, message: '请选择', trigger: 'change' }]
  }
```

[(185条消息) Element表单验证rules整理_element rules有哪些属性_pany_k的博客-CSDN博客](https://blog.csdn.net/weixin_49431999/article/details/109721425)





 label-position="left" 触发要给每个label赋长度，因为不这样的话每个label的width是100%



label-width="100px"





### descriptions描述列表

div slot="title" class="dialog-title  -------------描述列表自带的插槽，还有footer插槽，默认是显示的，在这把它设没了，学会使用

主要参数:span

```
<div v-if="item.boolean">
            {{ dialogData[item.value] ? '是' : '否' }}
          </div>
          <div v-else-if="item.aaa">
            123
          </div>
          <div v-else>
            {{ dialogData[item.value] || '--' }}
          </div>
```



b)  tooltip

c)  upload

d)  table

e）骨架屏

### dialog弹窗

##### [](https://element.eleme.cn/#/zh-CN/component/dialog#slot)Slot

| name   | 说明                    |
| :----- | :---------------------- |
| —      | Dialog 的内容           |
| title  | Dialog 标题区的内容     |
| footer | Dialog 按钮操作区的内容 |

```
<div slot="title" class="dialog-title">
```





### el-upload

自定义上传方法 :http-request="handleUpload"		

handleUpload (params: any) 	的params怎么来的

传进来的参只能叫params（因为是重写el-upload自带的方法缘故吧），params内容：

action、data、file



**运用在项目中文件上传页面**

​	:on-success="handleSuccess"						on-success	文件上传成功时的钩子



​    :http-request="handleUpload"					覆盖默认的上传行为，可以自定义上传的实现（用了:auto那啥的这个会失效）



​	multiple 

 是否支持多选文件   boolean	





### Tree 树形控件

[组件 | Element](http://10.14.2.33:12456/#/zh-CN/component/tree#scoped-slot)

 default-expand-all  是否默认展开所有节点   默认false

 :indent="20"  相邻级节点间的水平缩进，单位为像素 	默认16

 slot-scope="{ node, data }"  自定义树节点的内容，参数为 { node, data }

 @node-drag-start="handleDragStart"， @node-drop="handleDrop"

拖拽开始、拖拽完成

  :allow-drop="allowDrop"  拖拽位置的判断



### el-progress

```js
     <el-progress
            :width="200"
            :format="progressFormat"
            type="circle"
            :percentage="windowParams.loadingPercent"
          ></el-progress>
```



### Cascader 级联选择器





### el-select

```vue
   <el-select
                  v-model="formData.meetUnitId"
                  placeholder="请选择"
                  :disabled="idDetail"
                  :popper-append-to-body="false"
                  @change="handleUnitChange"
                  visible-change="requestMeetingPlace"
                >
                  <el-option v-for="item in unitList" :key="item.unitId" :label="item.unitName" :value="item.unitId">
                  </el-option>
                </el-select>
```



开启搜索：filterable



搜索的条件下将创建新的条目加入选择栏：

`allow-create`属性即可通过在输入框中输入文字来创建新的条目。注意此时`filterable`必须为真

 default-first-option： 按回车选中匹配项



封装一下还能将创建的条目添加进下拉选项





#### el-option

显示在页面的是绑定的：label，v-model选中的值是：value



# Webpack

看一下构建过程和loader和pulgin的区别

### 自定义打包的入口与出口

在 webpack.config.js 配置文件中，通过 entry 节点指定打包的入口。通过 output 节点指定打包的出口示例代码如下:

![image-20230904090704112](%E6%95%B4%E7%90%86.assets/image-20230904090704112.png)

每次重新打包把dist文件夹删掉（防止冲突）

改完filename名字，自然的也要把引入的民资改掉





## 插件

每次 修改完之后 都要自己用npm run dev 自己打包

所以有什么能监听代码修改帮我们自动打包吗

那就要用到插件了







#### webpack 插件的作用

通过安装和配置第三方的插件，可以拓展 webpack 的能力，从而让 webpack 用起来更方便。最常用的webpack 插件有如下两个:
webpack-dev-server
0
类似于node.js 阶段用到的 nodemon 工具
每当修改了源代码，webpack 会自动进行项目的打包和构建html-webpack-plugin
webpack 中的HTML 插件(类似于一个模板引擎插件)
可以通过此插件自定制indexhtml页面的内容



配置插件

### webpack-dev-server

webpack-devserver 可以让 webpack 监听项目源代码的变化，从而进行自动打包构建

![image-20230904091146231](%E6%95%B4%E7%90%86.assets/image-20230904091146231.png)

-D表示记录在开发节点下







2.2配置 webpack-dev-server
修改 packagejson -> scripts 中的 dev 命令如下
1"scripts": {
"dev":"webpack serve"，// script 节点下的脚本，可以通过 npm run 执行
再次运行 npm run dev 命令，重新进行项目的打包

![image-20230904091316213](%E6%95%B4%E7%90%86.assets/image-20230904091316213.png)



这样npm run dev之后会自动监听变化





### 访问自动打包生成的文件

之前的是webpack会严格按照配置的output去改引用，src下的文件就能使用了；

开启实时打包后，就不存在物理磁盘上了并没有在dist下



#### 2.3 打包生成的文件哪儿去了?

O不配置webpack-dev-server 的情况下，webpack 打包生成的文件，会存放到实际的物理磁盘上严格遵守开发者在webpack.config.js 中指定配置
根据 output 节点指定路径进行存放@配置了 webpack-dev-server 之后，打包生成的文件存放到了内存中不再根据output 节点指定的路径，存放到实际的物理磁盘上
提高了实时打包输出的性能，因为内存比物理磁盘速度快很多



![image-20230904092154088](%E6%95%B4%E7%90%86.assets/image-20230904092154088.png)







### html-webpack-plugin

html-webpack-plugin 是 webpack 中的 HTML 插件，可以通过此插件自定制 index.html页面的内容需求:通过 html-webpack-plugin 插件，将 sr 目录下的 index.html首页，复制到项目根目录中一份!



这样 打开端口就能看到页面了，而不是之前的那个文件夹

不需要dist 了，也不需要自己写那个首页的引入了，都是因为放到内存里和插件自己引用了



写在config.js里 ，很多配置是平级的写

![image-20230904092534875](%E6%95%B4%E7%90%86.assets/image-20230904092534875.png)



### 配置devserver节点

4.devServer 节点
在webpack.config,js 配置文件中，可以通过 devServer 节点对 webpack-dev-server 插件进行更多的配置示例代码如下:
i devServer :{
open: true，// 初次打包完成后，自动打开浏览器
host:127.0.0.1，// 实时打包所使用的主机地址
port: 80，// 实时打包所使用的端口号



## loader

就是处理非.js的文件咯 ，就有交给对应的加载器

1.loader 概述
在实际开发过程中，webpack 默认只能打包处理以.s 后缀名结尾的模块其他非 s 后缀名结尾的模块webpack 默认处理不了，需要调用 loader 加载器才可以正常打包，否则会报错!
loader 加载器的作用: 协助 webpack 打包处理特定的文件模块。比如:
css-loader可以打包处理css 相关的文件
less-loader 可以打包处理 less 相关的文件
babel-lader 可以打包处理 webpack 无法处理的高级JS语法



![image-20230904093601905](%E6%95%B4%E7%90%86.assets/image-20230904093601905.png)



#### 打包处理css文件

当webpack发现处理不了import的css文件时，就开始调用配置好的loader，loader处理好再交给webpack进行打包合并

运行 npm i style-loader@2.0.0	 css-loader@5.0.1 -D 命令，安装处理 cs 文件的 loader



在webpack.config.js 的 module -> rules 数组中，添加loader 规则如下:

![image-20230904093934513](%E6%95%B4%E7%90%86.assets/image-20230904093934513.png)1 module: { // 所有第三方文件模块的匹配规则
rules: [ // 文件后缀名的匹配规则
{ test: /\.css$/, use: ['style-loader'， 'css-loader'] )

其中，test 表示匹配的文件类型， use 表示对应要调用的 loader

注意: 
use 数组中指定的 loader 顺序是固定的
多个loader 的调用顺序是: 从后往前调用

### 打包处理less文件

![image-20230904094432662](%E6%95%B4%E7%90%86.assets/image-20230904094432662.png)

![image-20230904094609371](%E6%95%B4%E7%90%86.assets/image-20230904094609371.png)



### url-loader

webpack5自动内置了

![](%E6%95%B4%E7%90%86.assets/image-20230904094957012.png)



### loader对象配置方式

![image-20230904095152745](%E6%95%B4%E7%90%86.assets/image-20230904095152745.png)



### babel-loader

最近版的兼容了

![image-20230904095402069](%E6%95%B4%E7%90%86.assets/image-20230904095402069.png)



## 打包发布

### 为什么要打包发布

项目开发完成之后，使用 webpack 对项目进行打包发布的主要原因有以下两点:开发环境下，打包生成的文件存放于内存中，无法获取到最终打包生成的文件2开发环境下，打包生成的文件不会进行代码压缩和性能优化



加了server就是把它放进内存了

![image-20230904095701466](%E6%95%B4%E7%90%86.assets/image-20230904095701466.png)



![image-20230904095647250](%E6%95%B4%E7%90%86.assets/image-20230904095647250.png)



### 整理dist目录下的文件



用插件删除旧dist目录

![image-20230904100141539](%E6%95%B4%E7%90%86.assets/image-20230904100141539.png)





### 企业级项目的打包发布

企业级的项目在进行打包发布时，远比刚才的方式要复杂的多，主要的发布流程如下生成打包报告，根据报告分析具体的优化方案
Tree-Shaking
为第三方库启用CDN 加载
配置组件的按需加载
开启路由懒加载
自定制首页内容
在后面的 vue 项目课程中，会专门讲解如何进行企业级项目的打包发布





# Pinia

安装后使用，less是默认配置的不需要加



[一文搞懂pinia状态管理（保姆级教程） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/533233367)



## 数据持久化

[pinia-plugin-persistedstate(基础) - 掘金 (juejin.cn)](https://juejin.cn/post/7255855818595024954)

[uniapp项目实战第五章：小程序Pinia持久化_极客李华的博客-CSDN博客](



# uniapp

在8_29里







# 其他积累

### 编程技巧

clg

快速打印



使用 `Ctrl + ~` 开关终端，

 `Ctrl + J` 则是开关 Panel ，即含有终端、调试器的底部容器。



 `Ctrl + D`     快速改值

`Ctrl + i` 唤起代码提示





## 日期格式化day.js

$xxDateFormat

```js
const dateFormat = function(value: any, flag: any) {
  if (!value) return '-'
  if (flag === null || !flag) {
    return dayjs(value).format('YYYY-MM-DD HH:mm')
  } else {
    return dayjs(value).format('YYYY-MM-DD')
  }
}

Vue.prototype.$xxDateFormat = dateFormat
Vue.prototype.$xxDateFormat.dateTime = dateFormat
```



```js
 renderDate(val: any) {
    return val ? dayjs(val).format('YYYY-MM-DD') : ''
  }
```







## lodash库	[**Lodash 中文文档**](https://www.lodashjs.com/)

对象，数组操作的语法库，深拷贝，防抖，节流

#### lodash节流使用

搜索栏的联想词的出现

```js
 onWindowMessage (message: any) {
    // 创建一个节流函数，在 wait 秒内最多执行 func 一次的函数
    throttle(() => {
      if (message.data.keyDigNumGather) {
        if (message.data?.keyDigNumGather === this.subParams.keyDigNumGather) {
          this.$emit('refreshInit')
        } else if (message.data?.keyDigNumGather === this.treeData.keyDigNumGather) {
          this.$emit('refreshInit')
        }
      }
    }, 500)()
  }
```



## signature_pad插件

电子签名

把画布变成签名版了？

```js
    const canvas: any = document.querySelector('canvas')
      this.signaturePad = new SignaturePad(canvas, {
        minWidth: 5,
        maxWidth: 10,
        // penColor: '#08BCB0',
        penColor: '#333',
        backgroundColor: '#ecfafa'
      })
```



项目里面用了插件把组件包装成了一个类，所以里面写的方法和其他地方不一样，其他都是赋给变量的，项目里写的是类方法，能用es6的简写形式







## contextMenu

[Element: contextmenu event - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/contextmenu_event)

**`contextmenu`** 事件会在用户尝试打开上下文菜单时被触发

[vue3+ts开发vue3-context-menu插件 - 掘金 (juejin.cn)](https://juejin.cn/post/6974596228914872350?searchId=202307191727067A339FB81AB9CD657070)





## websocket

[一文吃透 WebSocket 原理 刚面试完，趁热赶紧整理 - 掘金 (juejin.cn)](https://juejin.cn/post/7020964728386093093)





## vuedraggable

move 拖拽事件里面传的一个事件对象

利用他封装好的传的东西去完成业务流程

```js
//move回调方法
onMove(e,originalEvent){ 
         console.log(e);
         console.log(originalEvent);
         //false表示阻止拖拽
         return true;
  },  
//e对象结构
draggedContext: 被拖拽的元素
      index: 被拖拽的元素的序号
      element: 被拖拽的元素对应的对象
      futureIndex: 预期位置、目标位置
relatedContext: 将停靠的对象
      index: 目标停靠对象的序号
      element: 目标的元素对应的对象
      list:  目标数组
      component: 将停靠的vue组件对象
```

move里并没有让它成功做拖拽，而是找到了它的原生的位置id和拖拽之后的位置存起来了



[vue.draggable move 自定义控制那些元素可以拖拽或不允许拖拽并控制是否允许停靠 - itxst.com](https://www.itxst.com/vue-draggable/ufjv2i7j.html)





## vue-class-component（registerHooks）



把组件内守卫和组件缓存合起来理解

原来那个像注解的东西叫类组件

[Additional Hooks | Vue Class Component (vuejs.org)](https://class-component.vuejs.org/guide/additional-hooks.html)

```js
附加钩子
如果你使用一些 Vue 插件，比如Vue 路由器，您可能希望类组件解析它们提供的钩子。在这种情况下，允许您注册这样的钩子：Component.registerHooks

import Component from 'vue-class-component'
Component.registerHooks([
  'beforeRouteEnter',
  'beforeRouteLeave',
  'beforeRouteUpdate'
])
```



```js
Component.registerHooks(['beforeRouteLeave'])
```

```js
//	它的功劳
import { Component, Vue, Watch, Prop, Ref } from 'vue-property-decorator'
```







## vuex-module-decorators

[Vue & TypeScript 初体验 - 使用Vuex (vuex-module-decorators) - 掘金 (juejin.cn)](https://juejin.cn/post/6844904003633954829?searchId=2023080715173976B24BC43AF1CF1DA7F1#comment)

简单的看了下vuex

action	写业务逻辑（判断、请求）

mutation 操作数据

有点像mvc   业务层...









## wangeditor

富文本编辑器的使用 wangeditor for vue





## Jenkins

### [Jenkins详细教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/157592663)





## qs库

axios的 get 方法 params 传参，在输入框中输入某些特殊字符 例如中括号、Json格式参数等，请求时会直接报 400 错误，Bad Request

方案：在创建 axios 实例时，增加可选的[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)属性 paramsSerializer，按需求使用encodeURIComponent、JSON.stringifyt等方法处理参数，在负责序列化 'params’的函数中使用自定义参数的序列化



[axios请求传参自定义paramsSerializer序列化_axios paramsserializer_码大星的博客-CSDN博客](https://blog.csdn.net/hututu3/article/details/123222938)

## 插件

GitLens — Git supercharged

Git History



[第 1 章: 我们在做什么？ · 函数式编程指北 (gitbooks.io)](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html)

## Git

### 我自己的笔记使用git

#### git stash pop 

git stash pop 后会自动把冲突抛出来，这个时候解决冲突后就直接push了吧

[Learn Git Branching](https://learngitbranching.js.org/?locale=zh_CN)





#### 回退提交


git reset --soft HEAD^







### 在项目里的运用





git clone 地址 -b  分支

#### git操作：提交到master

先保存到暂存区 git stash		等下要拉代码的，别把自己代码冲点

然后拉取master 最新代码	git pull origin master	(应该是看有没有新代码提交上去的)

再把自己代码拿出来  		git stash pop



转入github desktop   进行add commit  push 操作



提交 feat  fix





```js
1、git stash

    备份当前工作区的内容，保存到git 栈中，从最近的一次commit中读取相关内容

2、git pull  或者做其他的工作    

3、git stash pop

    从git栈中获取到最近一次stash进去的内容，恢复工作区的内容。。获取之后，会删除栈中对应的stash。。

    由于可能会stash多次，git使用栈管理，我们可以使用git stash list查看所有的stash
 4. git stash clear

        清空git栈

还可以git reset --hard放弃本地修改，然后就可以git pull了。。但是不推荐使用gitreset --hard指令，实在是太危险啦！
```

#### 分支

![image-20230629192719908](%E6%95%B4%E7%90%86.assets/image-20230629192719908.png)

git checkout 

git merge （要合并到）   合并

`git pull` 就是 fetch 和 merge 的简写

`git pull --rebase` 就是 fetch 和 rebase 的简写！

git rebase （x分支）   合并分支的方法--把当前分支复制到x分支上。

Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。**拉公共分支最新代码**

git pull -r或git pull --rebase

（好像只有个人开发用？）

![img](%E6%95%B4%E7%90%86.assets/f0729d5bc6504c2283ecff9fdb3e484a.png)



------

git config --list

git credential-manager uninstall

 

------

源代码管理，中

+号（暂存更改）  代表是git add   

------

**git push <remote> <place>**

命令后的origin 参数 代表远程仓库

```
git push origin main
```

把这个命令翻译过来就是：

*切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。*

我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。

要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了

1. `<remote>`：远程仓库的名称。它指定了你要将代码推送到哪个远程仓库。例如，`origin` 是默认的远程仓库名称。
2. `<branch>`：分支的名称。它指定了你要推送哪个分支的代码。例如，`master` 是默认的主分支名称。
3. `--all`：推送所有分支到远程仓库。使用这个参数可以将本地所有分支都推送到远程仓库。
4. `--tags`：推送所有标签到远程仓库。使用这个参数可以将本地所有标签都推送到远程仓库。
5. `--force`：强制推送。使用这个参数可以强制将代码推送到远程仓库，即使有冲突或者会覆盖已有的提交。
6. `--set-upstream` 或 `-u`：设置上游分支。使用这个参数可以将当前分支与远程分支关联起来，以后可以直接使用 `git push` 推送代码。
7. `<refspec>`：自定义引用规范。它可以指定要推送的分支或标签的引用规范。例如，`refs/heads/feature`



------



##### 学习内容

查看log

![image-20230629191624781](%E6%95%B4%E7%90%86.assets/image-20230629191624781.png)









## Token

token的两种方案：

- 将 token 放在 cookie 里；
- 将 token 放在请求头里，用 Authorization 字段

**认证步骤解析**

1. 客户端发送登录请求
2. 服务端校验账号密码，生成 Token，并返回给客户端
3. 收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中
4. 客户端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端
5. 服务端拿到 Token，做解密和签名校验，通过校验返回数据，否则返回 401



感觉没有找到自己想要看的东西





# TODO



浏览器输入url到页面加载全过程