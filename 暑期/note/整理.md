# 项目

## 查询页面

写api有三部曲

#### 查询、重置按钮逻辑

handleResetQuery事件

把搜索框的内容清空

深克隆咱们的const变量

重新赋searchParams--解构，其他照搬，只有userAuditStatus重赋，是query

就为空，其他就不管

最后请求 this.fetchDeclareSearchPage()

最后请求数据fetch.post('/xiangmu/declareSearch/page', this.searchParams



**这里顺着引申下的获取数据**

表单数据和下拉栏的数据是获取是不一样的（后者是要送进elementUI的对数据格式要求很高），下拉栏的数据需要接过来先做处理，label、value、children



### Managent页面：

#### v-bind=“$attrs、v-on="$listeners"部分

##### v-bind="$attrs"

主要用于组件之间的隔代传值，**高层级向底层级传值**

A组件中的值需要直接传给C，那么就需要在B中设置v-bind="$attrs"，然后在C组件中用prop接收，此时就直接把值传给了C组件。

##### v-on="$listeners"

主要用于底层组件向高层组件传递信息

我的理解，在这里是二次封装el-table 时用到了，

封装el-table里的	<el-table-column时，el-table 里

我知道它是跨级通信用到的，但是它到底是怎么用的呢



managent页面：

![image-20230630104058265](%E6%95%B4%E7%90%86.assets/image-20230630104058265.png)

headers里面加了想要加这样的样式的，一定要加component，后面会提到用到了table-col自带插槽里



Grid里的 :total="total"，就是通过v-bind=“$attrs传给子了的，没人用prop接收



```
      <html-content
        v-else-if="col.component"
        v-bind="$attrs"
        v-on="$listeners"
        :html="col.component(scope.row, index)"
        :row="scope.row"
        :index="index"
      ></html-content>
```

DynamicColumn组件下自己写了htmlContent组件

```
   htmlContent: {
      props: {
        html: String,
        row: Object,
        index: Number
      },
      render (h: any) {
        const self: Vue = this
        const component = Vue.extend({
          template: `<div @click.stop="onComponentClick">${self.$props.html}</div>`,
          methods: {
            onComponentClick () {
              this.$children.forEach((item: any) => {
                self.$emit(item.$attrs.clickName, self.$props.row, self.$props.index)
              })
            }
          }
        })

        return h(component, {
          // on: {
          //   click: function() {
          //     console.log(111)
          //     ;(self as any).aaa()
          //   }
          // }
        })
      }
    }
```

   template: `<div @click.stop="onComponentClick">${self.$props.html}</div>`,

这里的${self.$props.html}

外面

 :html="col.component(scope.row, index)"

col是sortHeaders里的遍历的item

喏，就是这里component

![image-20230630104058265](%E6%95%B4%E7%90%86.assets/image-20230630104058265.png)



​      this.$children.forEach((item: any) => {

荣哥说，外面一定要用component的原因，要不然这里遍历的就是空元素了（没有children）$children是指这个下面的整个组件，不是元素啥的



 如果heade里的component如果有点击方法，就执行咯，(还是问一问吧)









## Grid（含studentInfo）

**grid里的动态栏**

col是i从grid里传进来的item



#### DynamicColumn组件

封装的el-table



 数据  :data="items"通过 v-bind="$attrs"也传进DynamicColumn组件了



DynamicColumn组件传进去的数据 :col="item"

item 就是sortHeaders   v-for="(item, index) in sortHeaders"

DynamicColumn组件就开始根据col渲染表头、表格

  :label="col.text"

  :prop="col.value"

label是表头，prop是表格



#### 日期处理

```js
{{ dateFormatter(scope.row[scope.column.property], col.dateType) }} 

dateFormatter(time: any, timeFormat: string | true) {
    if (dayjs(time).isValid()) {
      return timeFormat === true ? dayjs(time).format('YYYY-MM-DD') : dayjs(time).format(timeFormat)
    } else {
      return ''
    }
  }
```







#### **组件传递**

Vue组件的自我调用，称之为组件传递。原理相当于递归。DynamicColumn组件，本质上是element-ui 中的 el-table-column的封装。目的为了满足树形表格的需求。

注意组件调用必须要满足以下条件:

\1.     一定要注册组件名

![img](%E6%95%B4%E7%90%86.assets/clip_image002.jpg)

\2.     在本组件（如：DynamicColumn中）直接调用自己，所传参数与非同名组件是一样的。

![img](%E6%95%B4%E7%90%86.assets/clip_image004.jpg)

\3.     

一定要有判断自我调用的条件，否则会导致程序崩溃，相当于递归也需要一个结束递归的判断。



#### 疏通插槽

数据是一路往下传的，

header=> sortHeaders=>col

headers里的value 对应 eltable的prop，label（表头）对应text

 :label="col.text"		  :prop="col.value"





 **studentInfo**组件部分：

```js
        <template #operate="{ scope }">
          <el-button class="color-green" @click.native.stop="toDetail(scope.row, '详情')" type="text"
            >学员详情</el-button
          >
          <el-button class="color-green" @click.native.stop="toDetail(scope.row, '学习考试记录')" type="text"
            >考试记录</el-button
          >
        </template>
```

**Grid**组件部分：

```js
    <!-- 这是作用域插槽父组件里用的， -->

     <span v-if="item.slotName" :slot="item.slotName" slot-scope="{ scope }">

      <!-- 把上面的name、scope传给父了 -->

     <slot :name="item.slotName" :scope="scope"></slot>

    </span>
```

Grid中**dynamic-colum**组件部分：

```js
  <!-- elementui的el-col自带插槽，提供给你让你可以修改列内容格式的 -->
    <template slot-scope="scope">
      <div
        v-if="col.template"
        @click.stop="onTemplateClick($event, scope.row, index)"
        v-html="col.template(scope.row, index)"
      ></div>
      <html-content
        v-else-if="col.component"
        v-bind="$attrs"
        v-on="$listeners"
        :html="col.component(scope.row, index)"
        :row="scope.row"
        :index="index"
      ></html-content>
		.....
      <!-- 如果发现有携带的数据是插槽类型，就是提供占位符咯，也就是grid里index里的添加的作用域插槽 -->
      <slot v-else-if="col.slotName" :name="col.slotName" :scope="scope" />
    </template>
```

![image-20230629170732724](%E6%95%B4%E7%90%86.assets/image-20230629170732724.png)



### Echart

## 

## 详情页面、弹窗

## 文件上传

文件上传，下载，预览 TreeFile2为例

   [长沙市农业项目全生命周期管理系统 (申报端)](http://10.14.3.27:4933/crowd/replenishment?_key=1687940181646)

### 整体逻辑

![Snipaste_2023-07-06_10-21-48](%E6%95%B4%E7%90%86.assets/Snipaste_2023-07-06_10-21-48.png)

2部分是在upload的.then中，.then中调用的是handleSuccess方法，先放到变量里在点击页面的发布时，上传到业务数据库中，就是3的部分

[智慧农业农村云上资料库](http://10.14.3.27:4933/sub/subSystem-cloud/keyWork/list?menuId=12941)



- 1部分就是upload方法



const uploaderClass = new UploaderClass({

   files: [params.file],

   beforeUpload: () => data,

   fileExists: fileUploadExists,

   uploadChunk: fileUploadChunk

  })

签名this.signature属性在这里用上了



// 获取签名

 getSignature () {

  comService.getSignature({ storeId: 'op' }).then(res => {

   **this.signature** = res.data

   const { filePermissionVo, signature } = res.data

   **this.customAuth** = Object.freeze({ signature, filePermissionVo })

  })

 }





#### .start() 方法





```
  async start() {
    const beforeUploadData = (await this.beforeUpload()) || {}
    const res = []
    for (let i = 0, l = this.files.length; i < l; i++) {
      this.files[i].registerData(beforeUploadData)
      const data = await this.files[i].start(beforeUploadData)
      res.push(data)
    }
    return res
  }
```







- 2部分是在upload的.then中，.then中调用的是handleSuccess方法，先放到变量里在点击页面的发布时，上传到业务数据库中，就是3的部分



- 3部分	handleRelease方法 ，

  ```
    handleRelease () {
      // 任一表单项被校验后触发
      this.FormRef.validate().then((valid: boolean) => {
        let req: any
        if (this.isEdit) {
        是编辑就调更新接口
          req = jobUpdate(this.form)
        } else {
          req = importJobAdd(this.form)
        }
        req.then((res: any) => {
          this.$message.success(`${this.title}资料上传成功`)
          this.$xxTab.close()
          this.$xxTab.open('subSystem-cloud', '重点工作动态一览', {})
        })
      })
    }
  ```

  重点工作页面就是那个我的资料页面

### :on-success="handleSuccess"

on-success	文件上传成功时的钩子

把linkGuid文件名等信息，给到业务系统数据库中保存

```
  handleSuccess (res: any) {
    const { fileName, linkGuid } = res
    console.log(JSON.stringify(this.form.files, null, 2))
    const hasUploaded = this.form.files.find((item: any) => item.fileLinkId === linkGuid)
    console.log(linkGuid, fileName)
    if (!hasUploaded) {
      this.form.files.push({
        fileLinkId: linkGuid,
        fileName,
        name: fileName
      })
    }
  }
```



```
<div slot="file" slot-scope="{ file }" class="custom-file-item" @click="handlePreview(file)">
```

file传进函数里，长这样

![image-20230713194617272](%E6%95%B4%E7%90%86.assets/image-20230713194617272.png)

由:file-list="form.files"得来

form.files就是上传的文件



## 文件预览

[长沙市农业项目全生命周期管理系统 (申报端)](http://localhost:4933/crowd/projectDetailPage?_key=1689560935945)

在资料上传的新增资料里

在el-upload里使用了slot=file完成了自己重写了这个显示

![image-20230829100119447](%E6%95%B4%E7%90%86.assets/image-20230829100119447.png)



本来的：

![image-20230829100152242](%E6%95%B4%E7%90%86.assets/image-20230829100152242.png)





整段代码：

```vue
     <el-upload
              action=""
              accept=".pdf,.jpg,.png,.jpeg,.doc,.docx,.txt,.xls,.xlsx,.wps,.ofd"
              :file-list="form.files"
              :http-request="handleUpload"
              :on-success="handleSuccess"
              class="file-upload"
              :class="{ empty: !form.files.length }"
              multiple
            >
              <div class="upload-trigger">
                <span class="upload-icon"></span>
                上传文件,请<el-button size="small" type="text">点击上传 </el-button>
              </div>
              <div slot="file" slot-scope="{ file }" class="custom-file-item" @click="handlePreview(file)">
                <svg-icon class="icon-size-16" :icon-class="fileIcon(file.name)" />
                <span class="file-name ellipsis">{{ file.name }}</span>
                <span class="status">
                  <i class="el-icon-success"></i>
                  上传成功
                </span>
                <el-button
                  type="text"
                  class="del-btn"
                  icon="el-icon-delete"
                  @click.stop.prevent="handleBeforeRemove(file)"
                ></el-button>
              </div>
            </el-upload>
```







之前看的这个补正材料详情，现在没了

  [长沙市农业项目全生命周期管理系统 (申报端)](http://10.14.3.27:4933/crowd/replenishment?_key=1687940181646)

我的项目里的材料信息 projectDetailPage页面





### 纵览

鉴权、上传、回显、根据类型（pdf是用的插件）

[前端文件流、切片下载和上传：优化文件传输效率与用户体验 - 掘金 (juejin.cn)](https://juejin.cn/post/7255189826226602045)



点projectDetailPage 里的.nav-header就切换到材料信息显示 TreeFile2了

TreeFile2里写文件预览，数据来自projectDetailPage 依赖注入，点击文件位置有左键（双击？）和右键方法，传参给方法，让具体方法内容由projectDetailPage 写

```js
  // 打开附件材料预览弹窗 -> 通过父级调用
  showPreviewWindow(data: any) {
    if (!this.isPlenishment && !data.isWrite && data.isDir) {
      return
    }
    clearTimeout(timer)
    timer = null
    if (data?.isDir) return
    if (data) {
      // data.roles = node.roles
      this.selectedData = data
    }
    this.OPHandle.toggleAttachWindow(true, this.selectedData, false)
  }

```

toggleAttachWindow就是projectDetailPage 里的方法



WindowPreview在projectDetailPage 中

#####  @Provide() OPHandle: projectDetailPage = this	传给treeFile

父组件通过`provide/inject`给子孙组件传值



##### WindowPreview页面

里面有进度条		el-progress

由windowParams.loading控制



图片是用blob显示



#### TreeFile2的入参

```js
      <TreeFile2
        v-show="navActive === 2"
        class="el-overflow self-table"
        ref="treeFile"
        :disabledClick="false"
        :treeData="declareTreeData"
        :publickParam="treeParam"
        :isArchive="isArchive"
        :isOperation="false"
        @refreshInit="initDeclareTreeData"
      >
      </TreeFile2>
```

isOperation  控制TreeFile2的上传按钮的显示、和文件右边的删除icon

declareTreeData，可以看成文件夹----材料信息页面的数据里除了null的

来自

```js
 // 申报材料
  async initDeclareTreeData() {
   const { data }: any = await fetch.get('/xiangmu/prj/box/declareTree', {
```



```js
subParams值:
{
	"name":"JY0712测试项目",
	"projectKind":"农业企业升级发展项目",
	"projectType":"农业企业升级发展项目",
	"projectClassification":"农业企业升级发展项目（龙头企业）",
	"applyStatus":"审批中","applyType":"项目申报",
	"updateTime":"2023-07-12T08:48:41.735Z",
	"keyDigNumGather":"411926250768367616",
	"applyId":"843621702528208896",
	"projectCode":"411926250768367616",
	"thirdId":"8111",
	"applyUserId":"0",
	"canGetBack":true,
	"projectInfoType":1,
	"opinion":null
	}
```



```js
  this.treeParam 
  = {
      keyDigNumGather: this.subParams.keyDigNumGather || this.subParams.projectCode,
      keyTypeCode: this.subParams.keyTypeCode,
      procDefId: '',
      roles: []
    }
```



```js
DeclareTreeData的值
[
    {
        "id": "1",
        "label": "项目申报",
        "parentId": null,
        "materialTypeId": null,
        "fileLinkId": null,
        "fileSize": null,
        "isWrite": null,
        "isDir": true,
        "roles": null,
        "keyTypeCode": null,
        "keyDigNumGather": null,
        "subid": null,
        "children": [
            {
                "id": "1574581296242364418",
                "label": "营业执照",
                "parentId": null,
                "materialTypeId": "1574581296242364418",
                "fileLinkId": null,
                "fileSize": null,
                "isWrite": false,
                "isDir": true,
                "roles": [
                    "1571775970224902146"
                ],
                "keyTypeCode": 2,
                "keyDigNumGather": "411926250768367616",
                "subid": null,
                "children": [
                    {
                        "id": "411926517010202624",
                        "label": "习大大.png",
                        "parentId": null,
                        "materialTypeId": "1574581296242364418",
                        "fileLinkId": "411926516620914688",
                        "fileSize": "109719",
                        "isWrite": false,
                        "isDir": false,
                        "roles": [
                            "1571775970224902146"
                        ],
                        "keyTypeCode": 2,
                        "keyDigNumGather": "411926250768367616",
                        "subid": null,
                        "children": null
                    }
                ]
            },
            {
                "id": "1635184496867282945",
                "label": "其他",
                "parentId": null,
                "materialTypeId": "1635184496867282945",
                "fileLinkId": null,
                "fileSize": null,
                "isWrite": false,
                "isDir": true,
                "roles": [
                    "1571775970224902146"
                ],
                "keyTypeCode": 2,
                "keyDigNumGather": "411926250768367616",
                "subid": null,
                "children": []
            }
        ]
    }
]
```

#### 其他参数

##### 右键菜单

```js
 contextMenu: any[] = [
    {
      icon: 'x-yuedu',
      text: '预览',
      handler: (data: any) => {
        this.showPreviewWindow(data)
      },
      isFile: true
    },
    {
      icon: 'x-shangchuan4',
      text: '上传',
      handler: () => {
        ;(this.$refs.upload as any)?.$children?.[0].$refs.input.click()
      },
      isDir: true
    },
    {
      icon: 'x-shuaxin2',
      text: '刷新',
      handler: () => this.$emit('refreshInit')
    },
    {
      icon: 'x-xiazai3',
      text: '下载',
      handler: (data: any) => this.download(data)
    },
    {
      icon: 'x-daiban-xuanzhong',
      text: '签章',
      handler: (data: any) => this.handleSign(data)
    },
    {
      icon: 'x-bianji1',
      text: '重命名',
      handler: (data: any) => {
        this.showReName(data)
      }
    },
    {
      icon: 'x-shanchu',
      text: '成果作废',
      handler: (data: any) => this.cancelAchievement(data)
    },
    {
      icon: 'x-laji1',
      text: '删除',
      handler: (data: any) => this.remove(data)
    }
  ]
```



### TreeFile2内容







```js
 <div
        slot-scope="{ node, data }"
        class="tree-node"
        @click.stop="chooseed(data, node)"
        @dblclick.stop="showPreviewWindow(data, node)"
        @contextmenu="contextMenuFliter(data)"
        v-context-menu="{ contextMenu, data }"
      >
```

单击选中某一个文件 双击预览，

#### 单击逻辑

一键阻止事件冒泡，只让它执行我们的函数





#### 双击

```js
  showPreviewWindow (data: any) {
    if (!this.isPlenishment && !data.isWrite && data.isDir) {
      return
    }
    clearTimeout(timer)
    timer = null
    if (data?.isDir) return
    // 可写，不是文件夹
    if (data) {
      // data.roles = node.roles

      this.selectedData = data
    }
    this.OPHandle.toggleAttachWindow(true, this.selectedData, false)
  }
```





#### 右键

通过不允许点击文件夹实现禁用上传等--

**实现：**

```js
  @contextmenu="contextMenuFliter(data)"
  v-context-menu="{ contextMenu, data }"
```

绑定右键菜单事件，点右键时会对菜单做个过滤，contextMenuFliter方法

```js
  contextMenuFliter (data: any) {
    this.selectedData = data
    this.filterAcceptFun(data.materialSuffixes)
```

##### filterAcceptFun方法

```js
  filterAcceptFun (str: string) {
    if (str?.length > 3) {  
  //      attrs: any = {
  //        accept: '.'
  //        }
  // 将字符串 str 中的分号 ; 替换为逗号 ,，再将星号 * 替换为空字符串
      this.attrs.accept = str?.replace(/;/g, ',')?.replace(/\*/g, '')
    } else {
      this.attrs.accept = '.'
    }
  }
```

replace方法，正则表达式



##### contextmenu

[Element: contextmenu event - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/contextmenu_event)

**`contextmenu`** 事件会在用户尝试打开上下文菜单时被触发



##### setCurrentNode

通过 node 设置某个节点的当前选中状态，使用此方法必须设置 node-key 属性

(node) 待被选节点的 node

```
 this.tree?.setCurrentNode(data)
```



点击预览就调toggleAttachWindow，如果可写且不是文件夹

调注入过来的父级方法

```
 this.OPHandle.toggleAttachWindow(true, this.selectedData, false)
```







### WindowPreview文件预览详情页面

带着问题去看

文件上传怎样实现预览功能、需要监听哪些事件

图片预览怎么实现的，加载栏怎么实现的

数据selectedAttach来自这

```js
//就是传的点击的这个，data
@dblclick.stop="showPreviewWindow(data, node)"
 这个data来自 :data="treeData"
这个treeData来自	@Prop() treeData!: any
这个treeData来自父组件传入，:treeData="declareTreeData"
这个来自api请求的，  async initDeclareTreeData () {
    
```

图片预览的初始化是怎么显示的

```js
这么调用的
created
 this.currentFile = this.selectedAttach

 
//this.selectedAttach就是当前文件
 mounted () {
  this.onSelect(this.selectedAttach)


```

#### onSelect方法里

判断文件类型，设定时器让进度条执行，鉴权

请求previewTree的api

```js
//res长这样
{data: Blob, status: 200, statusText: 'OK', headers: {…}, config: {…}, …}
config
: 
{transitional: {…}, transformRequest: Array(1), transformResponse: Array(1), timeout: 1000000, adapter: ƒ, …}
data
: 
Blob
size
: 
109719
type
: 
"image/png"
[[Prototype]]
: 
Blob
headers
: 
{access-control-allow-methods: '*', access-control-allow-origin: '*', cache-control: 'max-age=180, public', connection: 'close', content-disposition: 'inline;filename="411926516520251392_.png.png"', …}
request
: 
XMLHttpRequest {onreadystatechange: null, readyState: 4, timeout: 1000000, withCredentials: false, upload: XMLHttpRequestUpload, …}
status
: 
200
statusText
: 
"OK"
[[Prototype]]
: 
Object
```

then方法中赋windowParams--loadingPercent: 100

```
 this.windowParams = {
          ...this.windowParams,
          tips: '',
          ifError: false,
          loadingPercent: 100
        }
```



最后loading: false吧进度条取消

```
.finally(() => {
        setTimeout(() => {
          this.windowParams = {
            ...this.windowParams,
            loading: false
          }
```





页面用el-dialog实现



:**before-close**="dialogBeforeClose"

 // 实现关闭弹窗

 dialogBeforeClose() {

  this.visible = false

 }



if -else  进度条和图片页面

图片页面里包含前进后退箭头



放大缩小函数，过会看

scale (val: number, step = 0.2) {



 // 鼠标左键按下拖动平移

 handleMove (event: any) {





# HTML

### editable

[contenteditable - HTML（超文本标记语言） | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes/contenteditable)



# CSS

### 背景渐变

#### linear-gradient()

CSS **`linear-gradient()`** 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于[``](https://developer.mozilla.org/zh-CN/docs/Web/CSS/gradient)数据类型，是一种特别的[``](https://developer.mozilla.org/zh-CN/docs/Web/CSS/image)数据类型。

```css
.simple-linear {
  background: linear-gradient(blue, pink);
}
```



### 文字省略

[css文字超出元素省略,单行、多行省略 - 掘金 (juejin.cn)](https://juejin.cn/post/7016631393165770759)

沪上阿姨那个下面的文字省略

 overflow: hidden;

 white-space: nowrap;

 text-overflow: ellipsis;



​	四行：overflow：hidden...

###  cursor: pointer;

设置光标类型



### calc()

```js
<div>

	<div class="head">标题</div>
	<div class="contain">内容</div>

</div>
<style>
	.head{
		height: 70px;
	}
	.contain{
		height: calc(100% - 170px);;
	}
</style>
```


对于以上代码，如果我们要让盒子中的“内容”占满“标题”以下的所有区域，可以给“标题”设置一个固定值（70px），然后让“内容”的高为100%减去“标题”的高度，只需要设置样式使用calc() 函数就可以了！

使用calc()函数时需要注意以下几点：

1. calc()函数用于动态计算长度值。
2. **calc()函数支持 “+”, “-”, “*”, “/” 运算，运算符前后都需要保留一个空格**。
3. calc()函数使用标准的数学运算优先级规则。

————————————————
版权声明：本文为CSDN博主「心。晴」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jingjing217/article/details/107963876



### **white-space: nowrap;**

主要目的就是让文字不换行吧

**所有空格、回车、制表符都合并成一个空格，文本不换行**

床(空格)前(空格)(空格)(空格)(空格)明月光，疑是地上霜
（回车）
举头望明月，低头(Tab)思故乡

![img](%E6%95%B4%E7%90%86.assets/6100773-79b94479e8d415dd.png)



### position定位

定位：position  是relative是才有before？这是为什么，去过一过position

好像是子绝父相的东西？--用这个的意义

`static`是`position`属性的默认值。如果省略`position`属性，浏览器就认为该元素是`static`定位。



相对定位/绝对定位 才有那四个属性

relative  基于默认位置 设置top、bottom，left、right



 position 设置为absolute/fixed  脱离标准流，在文档流中不占位，宽高由内容定。不占用父空间了，父元素不会被其撑开，

absolute 基于父位置，父写个relative 就是给子元素参考位置吧？***\*大概就是先把父设置为定位点\****

**希望子元素相对于父元素进行定位，又不希望父元素脱标的时候，我们才会会用到子绝父相。**

[阮一峰博客CSS position定位（relative、absolute、fixed）属性教程，sticky竟有此神奇妙用！-甲爸博客 (xiaoyunhua.com)](https://www.xiaoyunhua.com/4302.html)





#### after细线的样式逻辑：

因为其他没设，放大缩小默认是0，所以它设flex：1就占满了剩余空间

再把高度设为1，背景设为黑色，就成了细线

内容content：‘’





#### 页面响应式

flex布局



### **BFC**

[BFC是什么？10 分钟讲透BFC 原理 (itcast.cn)](https://www.itcast.cn/news/20201016/16152387135.shtml)

[面试官：谈谈你对BFC的理解？ · Issue #99 · febobo/web-interview · GitHub](https://github.com/febobo/web-interview/issues/99)





### VUE`<Transition>` 组件及CSS动画

`<Transition>` 

会在一个元素或组件进入和离开 DOM 时应用动画。

是一个内置组件，这意味着它在任意别的组件中都可以被使用，无需注册。它可以将进入和离开动画应用到通过默认插槽传递给它的元素或组件上。进入或离开可以由以下的条件之一触发：



1. `v-enter-active`：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。

2. 案列

   ```
   /*
     进入和离开动画可以使用不同
     持续时间和速度曲线。
   */
   .slide-fade-enter-active {
     transition: all 0.3s ease-out;
   }
   ```

   ...	...	...

```
.dialog-fade-enter-active {
 animation: dialog-fade-in 0.3s;
}

.dialog-fade-leave-active {
 animation: dialog-fade-out 0.3s;
}

@keyframes dialog-fade-in {
 0% {
  transform: translate3d(0, -20px, 0);
  opacity: 0;
 }
 100% {
  transform: translate3d(0, 0, 0);
  opacity: 1;
 }
}



@keyframes dialog-fade-out {

 0% {

  transform: translate3d(0, 0, 0);

  opacity: 1;

 }

 100% {

  transform: translate3d(0, -20px, 0);

  opacity: 0;

 }

}
```



##### CSS 的 animation[](https://cn.vuejs.org/guide/built-ins/transition.html#css-animations)

[原生 CSS 动画](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations)和 CSS transition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。

#### css动画

关键帧

[使用 CSS 动画 - CSS：层叠样式表 | MDN (mozilla.org)](







































# JS

[FormData 对象的使用 - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects)

## 隐式转换 

this.pieDataTotal += +element

+element  相当于 0+element，类型转化：如果element是string 那么会被转话为数字类型



  在 JS 中，只有 0，-0，NaN，""，null，undefined 这六个值转布尔值时，结果为 false，



## ==、===

#### 等于操作符

- 两个都为简单类型，字符串和布尔值都会转换成数值，再比较
- 简单类型与引用类型比较，对象转化成其原始类型的值，再比较
- 两个都为引用类型，则比较它们是否指向同一个对象
- null 和 undefined 相等
- 存在 NaN 则返回 false

#### 全等操作符

全等操作符由 3 个等于号（ === ）表示，只有两个操作数在不转换的前提下相等才返回 `true`。即类型相同，值也需相同

相等操作符（==）会做类型转换，再进行值的比较，全等运算符不会做类型转换



### 深浅拷贝

出现原因：基本类型数据保存在在栈内存中，引用类型数据保存在堆内存中，引用数据类型的变量是一个指向堆内存中实际对象的引用，存在栈中

#### 浅

##### Object.assign

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

const returnedTarget = Object.assign(target, source);

console.log(target);
// Expected output: Object { a: 1, b: 4, c: 5 }

console.log(returnedTarget === target);
// Expected output: true				
```

感觉和拓展运算符差不多

#### 深

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性







## filter

​    // filter() 方法，过滤规则是return的内容

​    // 第⼀个参数是⾥⾯的元素,第⼆个参数为元素索引值,第三个参数为数组本⾝

```js
  =  this.recordFileList = list.filter((item: any) => item.fileName && item.fileLink)

​    const temp = list.filter((e: any) => e.meetingProcess) 

​    this.meetingRecordList = temp.reduce((pre: any, cur: any) => {

​     // debugger

​     if (!pre.includes(cur.meetingProcess)) pre.push(cur.meetingProcess)

​     return pre

​    }, [])


```





## JS循环大总结， for, forEach，for in，for of, map

[从for in 和for of的区别吹到async await - 掘金 (juejin.cn)](https://juejin.cn/post/7241838768016605244?searchId=2023073108420003A71227E1225F90FD36#heading-0)







```js
  async getUserList() {
    const res = await getUserList()
    const userList = res.data || []
    this.userOptions = Object.entries(userList).reduce((pre, [name, children]) => {
      pre.push({ userName: name, children, userId: guid() })
      return pre
    }, [] as any)
    console.log(this.userOptions)
  }
```





### for  in（大部分用于对象）

**遍历对象键值(key，只有这一个参数),或者数组下标,不推荐循环一个数组**

**`for...in`** **语句**以任意顺序迭代一个对象的**除[Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol)以外的[可枚举](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Enumerability_and_ownership_of_properties)属性**，包括继承的可枚举属性。

`for ... in`是**为遍历对象属性而构建**的，不建议与数组一起使用（因为会把原型链上的东西也遍历上去），数组可以用`Array.prototype.forEach()`和`for ... of`，

那么`for ... in`的到底有什么用呢？





但我实际操作时发现是不能对**数组**操作的

**备注：** `for...in`不应该用于迭代一个关注索引顺序的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array)。

（因为使用`for in`会遍历数组所有的可枚举属性，包括原型）

```
for (variable in object)
  statement
  
  
variable
在每次迭代时，variable 会被赋值为不同的属性名。

object
非 Symbol 类型的可枚举属性被迭代的对象。
```



### for...of（不能遍历对象）

es6中的，**遍历的只是数组内的元素（加[]为[i,v]）**，不包括原型属性和索引,允许遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等.在 ES6 中引入的 for of 循环，以替代 for in 和 forEach() ，并支持新的迭代协议。



由来：

​	for...in 虽然是给对象用的，但它可以给数组用吗（可以）

for...of  可以遍历对象吗，不行，为什么，引出来

​	es6可迭代对象



#### 两者区别

`for of`适用遍历数/数组对象/字符串/`map`/`set`等拥有迭代器对象（`iterator`）的集合，但是不能遍历对象，因为没有迭代器对象，但如果想遍历对象的属性，你可以用`for in`循环（这也是它的本职工作）或用内建的`Object.keys()`方法



[for...in - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)



[Object.prototype.hasOwnProperty() - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)







[JS filter、map、reduce等十三种遍历数组方法详细总结🔥 - 掘金 (juejin.cn)](https://juejin.cn/post/7241875961130745911?searchId=20230728165000E73BF392152FF8C4C330#heading-2)

数组归并方法reduce()和reduceRight()。两个方法都会迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后，reduceRight()从数组的最后一项开始，向前遍历到第一项



### 数组迭代方法

- forEach是对数组的每一个元素执行一次给定的函数。
- map是创建一个新数组,该新数组由原数组的每个元素都调用一次提供的函数返回的值。

##### forEach()

只能对数组使用

对数组每一项都运行传入的函数，没有返回值

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
numbers.forEach((item, index, array) => {
    // 执行某些操作
});

arr[index] = item
```

```js
.forEach((item, index) => {
```



##### map()

**`map()`** 方法**创建一个新数组**，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];
let mapResult = numbers.map((item, index, array) => item * 2);
console.log(mapResult) // 2,4,6,8,10,8,6,4,2
```



`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历

```
or (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
```

在这放一起总结

对象的这些方法也是一样的,写成这样--Object.entries（obj）



### reduce

方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

#### 语法

```
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
```

#### 参数

| 参数                                      | 描述                               |
| :---------------------------------------- | :--------------------------------- |
| *function(total,currentValue, index,arr)* | 必需。用于执行每个数组元素的函数。 |
| *initialValue*                            | 可选。传递给函数的初始值           |

function

| 参数           | 描述                                     |
| :------------- | :--------------------------------------- |
| *total*        | 必需。*初始值*, 或者计算结束后的返回值。 |
| *currentValue* | 必需。当前元素                           |
| *currentIndex* | 可选。当前元素的索引                     |
| *arr*          | 可选。当前元素所属的数组对象。           |

这里说的初始值init就是方法逗号后面的那个初始值*initialValue*

 pre（total）：上一次调用 callbackFn 时的返回值。在第一次调用时，若指定了初始值 init，其值则为 init，否则为数组索引为 0 的元素 arr[0]。

cur：数组中正在处理的元素。在第一次调用时，若指定了初始值 init，其值则为数组索引为 0 的元素 arr[0]，否则为 arr[1]。
 index：数组中正在处理的元素的索引。若指定了初始值 init，则起始索引号为 0，否则从索引 1 起始。
 arr：用于遍历的数组。

https://blog.csdn.net/qq_52855464/article/details/126004138

[JS filter、map、reduce等十三种遍历数组方法详细总结🔥 - 掘金 (juejin.cn)](https://juejin.cn/post/7241875961130745911?searchId=20230728165000E73BF392152FF8C4C330#heading-2)







### 对象

`for...of` 语句用于遍历可迭代对象	(也能对数组用吧)

```
// 迭代映射对象
const map = new Map([["name", "John"], ["age", 30]]); 
for (const [key, value] of map) { 
    console.log(key, value); 
}
// name John
// age 30
```

这个博客写的真垃圾













### staic



静态方法是使用 static 关键字修饰的方法，又叫类方法，属于类的，但不属于对象，在实例化对象之前可以通过 **类名.方法名** 调用静态方法。（就跟Array.isArray的道理一样吗）

静态方法不能在对象上调用，只能在类中调用。

- #### `static` 使用方法总结

  - ### 静态方法 应该在 没有实例化的时候调用

  - ### 反而言之：静态方法不能在类的实例中使用



[JavaScript static 关键字是干嘛的？ - 掘金 (juejin.cn)](https://juejin.cn/post/6940556583482949663)







## js宏微任务

微任务：Promise 回调函数，宏任务：setTimeout 回调函数

项目开发中，遇到了定时器回调函数定时为0也能达到效果，达到页面数据请求完整，成功渲染（项目中的应用就是开新页面前请求数据在定时器中请求）

[js宏任务和微任务执行顺序详解 - 掘金 (juejin.cn)](https://juejin.cn/post/7219689062449446971)

`js` 在主线程中执行的顺序：宏任务 -> 宏任务 -> 宏任务 ...

宏任务和微任务在一个执行栈中执行，它们都会在里面排队等待执行，但宏任务的优先级是2，微是1，所以有微任务就会在当前宏任务执行完后就执行

在每一个宏任务中又可以产生微任务，当微任务全部执行结束后执行下一个宏任务。 【宏任务 [微任务]】 -> 【宏任务 [微任务]】-> 【宏任务 [微任务]】

1. 先执行同步和立即执行任务，比如说`console.log()、new Promise()`

2. 再依次执行微任务，比如说`thenable`函数和`catchable`函数

3. 当微任务执行完成后开始执行宏任务，比如说`定时器、事件回调`等

   await`命令就是内部`then`命令的语法糖，而then是咱们写的事件回调函数，就丢到微任务里了

   [(190条消息) 宏任务和微任务的一道经典面试题~_不二博客的博客-CSDN博客](https://blog.csdn.net/qq_39157944/article/details/105157472)



[(190条消息) 执行栈 同步任务 异步任务 宏任务 微任务 总结（含面试讲解）_孟章丶的博客-CSDN博客](https://blog.csdn.net/weixin_56119039/article/details/131781228?spm=1001.2014.3001.5501)

```JavaScript
async function method() {
  await method2();
  console.log(1)
}

function method2() {
  const promise = new Promise((resolve) => {setTimeout(() => resolve(), 0)});
  return promise;
}

function main() {
  method()
  console.log(2)
}

main()
```

2,1

微任务不是立即执行的----- method2()被调用风放进微任务里，然后返回回来就执行console.log(2)了

[JS事件循环机制（event loop）之宏任务/微任务 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903638238756878?searchId=20230717202441B6AAD292375E5C34690A#comment)







```js
const t1 = new Date()
setTimeout(() => {
    const t3 = new Date()
    console.log('setTimeout block')
    console.log('t3 - t1 =', t3 - t1)
}, 100)
​
​
let t2 = new Date()
​
while (t2 - t1 < 200) {
    t2 = new Date()
}
​
console.log('end here')

```

输出答案是 `200`。

整个脚本是第一个宏任务。计时器生成了第二个宏任务。只有第一个宏任务执行结束后才会执行第二个宏任务。





[JavaScript中this指向详细分析(译) - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/431472497)

箭头函数 this 会指向它所定义的地方，因此如果我们在使用一些框架，比如 Vue、小程序，在定义钩子函数或者属性方法的时候千万不能用箭头函数。

```javascript
export default {
    data() {
        return {
            a: 1,
        };
    },
    methods: {
        test: () => {
            console.log(this.a)
        },
    },
};export default {
    data() {
        return {
            a: 1,
        };
    },
    methods: {
        test: () => {
            console.log(this.a)
        },
    },
};
```

test 方法中是无法访问到 a 属性的，小程序中定义函数的时候也是同理。









只有`async`函数内部的异步操作执行完，才会执行`then`方法指定的回调函数。



**题目在博客中**

过一遍执行栈，先执行同步任务

console.log("同步任务1");

workFun()

```
console.log("同步任务2");
    if (mac) {
        console.log(mac);
    }
    return new Promise((resolve, reject) => {
        console.log("Promise中的同步任务");
        resolve("Promise中回调的异步微任务")
    })

```

console.log("同步任务3")



排好了不进入主线程的异步任务

```
宏任务：setTimeout， then(res => {    console.log(res); })

微任务：workFun()里嵌套微任务---- resolve("Promise中回调的异步微任务")

```



先执行所有同步任务，产生结果：

 console.log("Promise中的同步任务")为什么会先执行，----这是promise的

而resolve("Promise中回调的异步微任务")没执行--还在执行同步函数，这是个异步

```
同步任务1 
（执行同步任务workFun函数）
同步任务2
Promise中的同步任务
同步任务3
```



执行完同步任务，开始异步任务，执行当前所有微任务，产生结果：

```
Promise中回调的异步微任务
```



执行排好队的宏任务，也就是

setTimeout

 then(res => {    console.log(res); })



执行先前排队的setTimeout，依次执行里面的同步任务

```
console.log("异步任务中的宏任务");
workFun("定时器传递任务")
```

又排了两个宏任务，

```
setTimeout(() => {        console.log("定时器中的定时器（宏任务）");     }, 

console.log("异步任务中的宏任务");
```

此时宏任务：

.then(res => {        console.log('定时器中的:', res);    })

setTimeout(() => {        console.log("定时器中的定时器（宏任务）");     }, 



产生结果：

```
异步任务中的宏任务
同步任务2
定时器传递任务
```



执行workFun里的同步任务后，执行workFun里的微任务

产生结果：

```
Promise中的同步任务
```



继续执行宏任务：

1. 

   ```
    workFun("定时器传递任务").then(res => {        console.log('定时器中的:', res);    })
   ```

2. ```
   setTimeout(() => {        console.log("定时器中的定时器（宏任务）");     }, 0)
   ```

   



产生结果：.then(res => {        console.log('定时器中的:', res);    })

```
定时器中的: Promise中回调的异步微任务
定时器中的定时器（宏任务）
```







## Blob	

[JavaScript中的Blob你知道多少 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/500199997)

**一、Blob 是什么**

Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。**在 [JavaScript](https://link.zhihu.com/?target=http%3A//caibaojian.com/t/javascript) 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。**



### **2.2 属性**

前面我们已经知道 Blob 对象包含两个属性：[·](https://link.zhihu.com/?target=http%3A//caibaojian.com/blob.html)

- size（只读）：表示 `Blob` 对象中所包含数据的大小（以字节为单位）。
- type（只读）：一个字符串，表明该 `Blob` 对象所包含数据的 MIME 类型。如果类型未知，则该值为空字符串。

### **2.3 方法**

- slice([start[, end[, contentType]]])：返回一个新的 Blob 对象，包含了源 Blob 对象中指定范围内的数据。
- stream()：返回一个能读取 blob 内容的 `ReadableStream`。
- text()：返回一个 Promise 对象且包含 blob 所有内容的 UTF-8 格式的 `USVString`。
- arrayBuffer()：返回一个 Promise 对象且包含 blob 所有内容的二进制格式的 `ArrayBuffer`。

这里我们需要注意的是，**`Blob` 对象是不可改变的**。我们不能直接在一个 Blob 中更改数据，但是我们可以对一个 Blob 进行分割，从其中创建新的 Blob 对象，将它们混合到一个新的 Blob 中。这种行为类似于 JavaScript 字符串：我们无法更改字符串中的字符，但可以创建新的更正后的字符串。



### **三、Blob 使用场景**

### **3.1 分片上传**

File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的上下文中。所以针对大文件传输的场景，我们可以使用 slice 方法对大文件进行切割，然后分片进行上传，具体示例如下

### **3.2 从互联网下载数据**

我们可以使用以下方法从互联网上下载数据并将数据存储到 Blob 对象中，

### **3.3 Blob 用作 URL**

Blob 可以很容易的作为 `<a>`、`<img>` 或其他标签的 URL，多亏了 `type` 属性，我们也可以上传/下载 `Blob` 对象。下面我们将举一个 Blob 文件下载的示例，不过在看具体示例前我们得简单介绍一下 Blob URL。

**1.Blob URL/Object URL**

Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像，下载二进制数据链接等的 URL 源。在浏览器中，我们使用 `URL.createObjectURL` 方法来创建 Blob URL，该方法接收一个 `Blob` 对象，并为其创建一个唯一的 URL，其形式为 `blob:<origin>/<uuid>`，对应的示例如下：

blob:https://example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641

浏览器内部为每个通过 `URL.createObjectURL` 生成的 URL 存储了一个 URL → Blob 映射。因此，此类 URL 较短，但可以访问 `Blob`。生成的 URL 仅在当前文档打开的状态下才有效。它允许引用 `<img>`、`<a>` 中的 `Blob`，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。[·](https://link.zhihu.com/?target=http%3A//caibaojian.com/blob.html)

上述的 Blob URL 看似很不错，但实际上它也有副作用。虽然存储了 URL → Blob 的映射，但 Blob 本身仍驻留在内存中，浏览器无法释放它。映射在文档卸载时自动清除，因此 Blob 对象随后被释放。

但是，如果应用程序寿命很长，那不会很快发生。因此，如果我们创建一个 Blob URL，即使不再需要该 Blob，它也会存在内存中。

针对这个问题，我们可以调用 `URL.revokeObjectURL(url)` 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存。接下来，我们来看一下 Blob 文件下载的具体示例。







# ES6

[变量的解构赋值 - ECMAScript 6入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/destructuring)

https://blog.csdn.net/weixin_44566194/article/details/127568441?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168791277616782427483738%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168791277616782427483738&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127568441-null-null.142^v88^control,239^v2^insert_chatgpt&utm_term=%E9%BB%91%E9%A9%ACes6&spm=1018.2226.3001.4187



### 数组去重





对象数组不能单单使用includes

最好是用set，map

[(183条消息) JS数组对象使用new Set() 快速去重 - 戴向天_js new set()_戴向天的博客-CSDN博客](https://blog.csdn.net/weixin_41088946/article/details/118915409)

### var let 经典面试题

方法的作用域是单独的，等循环结束才执行？

**预解析**是在程序执行之前，会进行一遍预检。查找当前**作用域**内由 `function` 和 `var` 。并且每次更换作用域都会在此作用域中执行**预解析**

**变量提升**是指，在查找到由 `function` 和 `var` 后，首先在当前作用域的顶端定义好并赋给默认值。`var`的默认值为 `undefined`， `function`的默认值为**函数本身**

预解析和变量提升的过程中，并不会将变量赋值，而只是定义

方法优先级比var高

宏任务和微任务和循环里的方法调用顺序有什么关联吗（let面试题）

并没有，就只是变量提升

![image-20230703203656810](%E6%95%B4%E7%90%86.assets/image-20230703203656810.png)

代码意思：循环给arr赋值，在循环结束后调用让他们去找i

换成let 每个都是不同的，都有自己的块级作用域

var时，函数执行时循环已经结束了，所以i都是2，方法向上查找作用域，上级是全局左右域，

而let时，方法向上查找作用域，找到的是循环产生的块级作用域，

[彻底弄懂JavaScript作用域问题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/161398465)





### 使用类注意事项

三个注意点：

在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象。
类里面的共有属性和方法一定要加 this 使用。
类里面的 this 指向问题。
constructor 里面的 this 指向实例对象, 方法里面的 this 指向这个方法的调用者。



### **构造函数**

- **静态成员**：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。

- **实例成员**：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。

  静态成员有啥用



对象原型 __proto__ 

构造函数原型 prototype 

就是说用 prototype 构造，然后拿____proto__ 去拿去用？就是下发和向上查找机制的区别咯？

- __proto__对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性， 因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype。

  - ​	      console.log(ldh.__proto===Star.prototype);  true

    Star.prototype用来写、构造给下面的对象来使用

    ldh.__proto，用来看它上一级的构造函数

构造函数回去看视频

![img](%E6%95%B4%E7%90%86.assets/28b3161e66b44f808505753b5f09c9be.png)





### 继承：

核心原理：在构造函数里 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。

借用原型对象继承父类型方法

一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。 

 prototype 原型对象 = new 父类() 

把父类所有方法、原型链（构造方法）东西拿过来了，但也把自己的构造方法也变成了父类

所以要指回来    Son.prototype.constructor = Son

### ES6 类的本质

1.  class 本质还是 function。
2.  类的所有方法都定义在类的 prototype 属性上
3.  类创建的实例,里面也有 __proto__ 指向类的 prototype 原型对象





### 对象解构赋值

如果变量名与属性名不一致，必须写成下面这样。

把后面的名为foo的属性赋给了baz

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。

```javascript
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

[变量的解构赋值 - ECMAScript 6入门 (ruanyifeng.com)](https://es6.ruanyifeng.com/#docs/destructuring)





### 闭包会出现什么问题

开发中发现荣哥常常把参数用局部变量接过来再用

闭包的优点和缺点
优点
①保护变量安全 ，实现封装，防止变量声明冲突和全局的污染
②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）
③匿名自执行函数可以减少内存消耗

缺点
①被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；
②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响







### **spread 扩展运算符**

扩展运算符（spread）也是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，**对数组进行解包**。



**rest 参数 ：** function add(…args) 是放在函数传参

**spread：** fn(…tfboys) 是放在调用函数时

> 特性
>
> const tfboys=['AA','BB','CC']
> function chunwan(){
> console.log(arguments);
> }
> chunwan(...tfboys);  //0:'AA' 1:'BB' 2:'CC'



在解构赋值中，未被读取的可遍历的属性，分配到指定的对象**z**上面

```
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
```

注意：解构赋值必须是最后一个参数，否则会报错

解构赋值是浅拷贝









y= 24 

z = 13

37+5

return 42





### 对象

#### 属性的简写

简写的对象方法不能用作构造函数，否则会报错



#### 属性名表达式

```ts
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```





### 生成器，遍历器生成函数

直接看面试题吧，那个最好

Generator相当于JS实现的协程

![image-20230706190556106](%E6%95%B4%E7%90%86.assets/image-20230706190556106.png)

`Generator` 函数会返回一个遍历器对象，即具有`Symbol.iterator`属性，并且返回给自己

```
function* gen(){
  // some code
}

var g = gen();

g[Symbol.iterator]() === g
// true
```

通过`yield`关键字可以暂停`generator`函数返回的遍历器对象的状态

yield把这个代码分成几段，

函数的调用只是返回了个迭代器对象，要用.next才能进去（next恢复运行），并且卡在yield位置（yield暂停运行），并且把yield表达式的值给返回回去了，放在当前的返回对象中

第一次调用，Generator 函数开始执行，直到遇到第一个 yield 表达式为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 2

![image-20230706190914523](%E6%95%B4%E7%90%86.assets/image-20230706190914523.png)

![image-20230706190932367](%E6%95%B4%E7%90%86.assets/image-20230706190932367.png)

（上面这段代码需要注意的是，最后一个yield后面也被分成了代码段，所以.next依然能进去，所以是能输出语句的，但是迭代结束了，后续没有了，所以返回了undefined）

上面是yield的表达式是赋值过去的，咱们也可以传参传进去，这个就是.next的入参

(next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值)







![image-20230706191834756](%E6%95%B4%E7%90%86.assets/image-20230706191834756.png)



问题：这里的‘2 ’是不是就是默认值呀，并不是，就是迭代器返回回去的对象{value：的值，done: }



![image-20230706192418181](%E6%95%B4%E7%90%86.assets/image-20230706192418181.png)

.return也能主动返回结果

![image-20230706192833271](%E6%95%B4%E7%90%86.assets/image-20230706192833271.png)

不过大家肯定都是在函数里面才用调用咯，这里想演示做到同一个效果，只是想表达return的值传在这个value里来了

如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true ，表示遍历已经结束。



在这引申，yield就和一个return一样，next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值







使用场景：为不具备迭代器接口的对象提供了遍历操作

为什么没有.next，因为是用for...of遍历控制的，我只想要读它的值而已，我用yield主要是想让它去做返回

**再次提醒：**next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值

![image-20230706193908366](%E6%95%B4%E7%90%86.assets/image-20230706193908366.png)

![image-20230706193853900](%E6%95%B4%E7%90%86.assets/image-20230706193853900.png)

视频里说[key,value]就相当于.next把他给取出来了









### async  

处理Promise的，读取里面真实的数据



Generator 函数的语法糖

（1）内置执行器

Generator 函数的执行必须靠执行器，所以才有了 co 模块，而 async 函数自带执行器。也就是说， async 函数的执行，与普通函数一模一样，只要一行。

（2）更好的语义。

async 和 await ，比起星号和 yield ，语义更清楚了。 async 表示函数里有异步操作， await 表示紧跟在后面的表达式需要等待结果。

（3）更广的适用性。

（4）返回值是 Promise。

Generator  中  yield 返回值是 Iterator 对象，await返回值是 Promise。

`async` 函数返回一个 `Promise`对象，可以使用 `then`方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。







### Promise

#### 状态

`promise`对象仅有三种状态

- `pending`（进行中）
- `fulfilled`（已成功）
- `rejected`（已失败）

#### 特点

- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态
- 一旦状态改变（从`pending`变为`fulfilled`和从`pending`变为`rejected`），就不会再变，任何时候都可以得到这个结果

#### 实例方法

```js
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```



- then()

`then`是实例状态发生改变时的回调函数，第一个参数是`resolved`状态的回调函数，第二个参数是`rejected`状态的回调函

- catch()

`catch()`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数

- finally()

`finally()`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作



#### 构造函数方法

`Promise`构造函数存在以下方法：

- all()

- race()

- allSettled()

- resolve()

- reject()

- try()

  #### all()		&&操作（全真才真，一假全假）

  

`Promise.all()`方法用于将多个 `Promise `实例，包装成一个新的 `Promise `实例

const p = Promise.all([p1, p2, p3]);		

接受一个数组（迭代对象）作为参数，数组成员都应为`Promise`实例



只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`

有一个被`rejected`，`p`的状态就变成`rejected`



#### allSettled()

有时候，我们希望等到一组异步操作都结束了，不管每一个操作是成功还是失败，再进行下一步操作。但是，现有的 Promise 方法很难实现这个要求。

`**Promise.all()** `方法只适合所有异步操作都成功的情况，如果有一个操作失败，就无法满足要求。 **[Promise.all（）方法](https://blog.csdn.net/qq_52855464/article/details/125376557?spm=1001.2014.3001.5502)**

[Promise.allSettled（）方法介绍_潮汐未见潮落的博客-CSDN博客](https://blog.csdn.net/qq_52855464/article/details/125407602)



# TS

## 函数返回值和传参类型规定

```ts
function returnItem (param: string): string {
  return param
}

```

## 泛型

```ts
那么我们需要变量，这个变量代表了传入的类型，然后再返回这个变量，它是一种特殊的变量，只用于表示类型而不是值。
这个类型变量在 TypeScript 中就叫做「泛型」。

function returnItem<T>(param: T): T {
  return param
}

```

我们在函数名称后面声明泛型变量 `<T>`，它用于捕获开发者传入的参数类型（比如说string），然后我们就可以使用`T`(也就是string)做参数类型和返回值类型了。



[TypeScript入门之泛型 - 掘金 (juejin.cn)](https://juejin.cn/post/7109280052566556680)





```javascript
// 这能看懂吧？
// 标记 arg 是个 number 类型
// 标记 foo 返回值是个 string 类型
function foo(arg: number): string;

// 加上泛型，跟上面没区别
function foo<T>(arg: number): string;

// 改变一下 arg 的类型和 foo 的返回值类型
// 这里意思即为 foo 的返回值和 arg 的返回值类型永远相同
// 你传 foo(number) 进来，返回值就也是 number
// 你传 foo(string) 进来，返回值就也是 string
function foo<T>(arg: T): T;

```

冒号后面的`T`代表该函数返回的类型

函数的`<>`中的`T`是泛型声明：即有一个类型叫`T`，在后面可以用`T`指代这个还不知道的类型。

[javascript - ts 泛型 后面的那个冒号是干嘛的？ - SegmentFault 思否](https://segmentfault.com/q/1010000040694522)

## 装饰器	vue-property-decorator

让Vue2支持ts的秘诀

### @Ref

 @Ref("button") readonly button:any;

button 参数是只读的，类型是any



**普通的ref只能获取与元素，不能直接链式调用获取里面的方法**



**具名元素**

- `@Ref('refInTemplate') readonly xxxxElement!: ElementType`: 此时页面上需要有一个`ref=refInTemplate`的元素,把模板上 `ref="refInTemplate"`的元素赋给 `this.xxxxElement`

#### 项目中的使用



```js
  <el-form
          :model="form"
          :rules="rules"
          label-position="top"
          ref="FormRef"
          label-width="100px"
          class="dynamic-form"
        >
```



export default class Dynamic extends Vue {

 // 这么用了之后，就是可以使用this.FormRef了

 @Ref() FormRef!: any

##### 使用：

```js
  handleRelease () {
    // 任一表单项被校验后触发
    this.FormRef.validate().then((valid: boolean) => {
```



# VUE

二、什么是Model
我们经常见到“Model”，如MVC模式中的M就是指“Model”，MVVM中的“Model-View-ViewModel”，数据库抽象层中的“Model”等。那么什么是model呢？

通常，Model有如下几种用法：

等价于Entity，完全不具备其他业务逻辑代码。

当成数据库接口层，就是将数据库的读写、增删、查改都封装在Model中，经常出现“getUserById”这样的写法。

当成纯粹的业务逻辑类。

Model是模型，而不是“数据”，Model应该是利用Entity实体，来组合、处理、整合更上层、更抽象数据的类。是基于Entity的更高层的数据抽象与处理。
————————————————
版权声明：本文为CSDN博主「m1m-FG」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。

原文链接：https://blog.csdn.net/SakuraMG/article/details/128652284





------

**使用Transition内置组件及CSS transition完成动画**

[Transition | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/built-ins/transition.html#the-transition-component)

------





#### 创建vue3 项目

![image-20230706103915851](%E6%95%B4%E7%90%86.assets/image-20230706103915851.png)



### .sync 修饰符

没搞懂和v-on="$listeners"、v-bind=“$attrs有什么区别，（这个需要传出来的，那个就是将属性和事件父传孙）

在对一个 prop 进行“双向绑定,单向修改”的场景下--好像项目里也不是这个场景，因为子组件不能直接修改父组件，sync在2.3版本引入，作为一个事件绑定语法糖，利用[EventBus]，当子组件触发事件时，父组件会响应事件并实现数据更新，避免了子组件直接修改父组件传过来的内容。

.sync是一个语法糖。是父组件监听子组件更新某个props的请求的缩写语法

就是省写了$emit和父组件中回调函数，达到直接修改数据，荣哥说就当隔组件使用v-model，特别注意prop写法

```text
:money.sync="tatol"//等价
:money="total" v-on:update:money="total=$event"
```

$attrs---它是组件自身的一个属性，可以获取到传递给组件的所有没有用props声明接收的prop属性，除了class、style属性

提醒：prop 传递的属性不会被接收。父组件用prop接收了一些数据，那在子里面就不会$attr接收这些数据

prop 就想当于吃流水席，把自己想要的东西截下来了？



**项目中我的理解**：我需要在eltable里的table和table-column其实是父子关系封装的，但在我只是用eltable ，我不关心内部，只传东西给eltable，这个时候就需要在调用table-colum时写

<el-table-column v-if="showCheckbox" type="selection" v-bind="$attrs" v-on="$listeners"

让这个子组件接受父组件同样的东西，使得table，table-colum看起来是同层次的东西

[(181条消息) Vue中 $attrs、$listeners 详解及使用_明天也要努力的博客-CSDN博客](https://blog.csdn.net/ZYS10000/article/details/116017711)

[Vue：深入理解 Vue 的 .sync 修饰符 - 掘金 (juejin.cn)](https://juejin.cn/post/6977022803744653320)



### v-on="$listeners"、v-bind=“$attrs部分

总结在management页面里了

没用slot插槽占位符占位的slot也会存在$attr里，这东西像是一个捡漏的东西，你不要的东西就都给我吧，（起码东西没丢掉）

prop也一样



### 三个插槽

（＜slot＞、v-slot、slot-scope）

```
 <template #operate="{scope}">
具名插槽写法（并不是吧就是作用域插槽，具名插槽子组件里写的是name，这里写的slot-scope，而且这个有参数，作用域插槽就是带参传递插槽）
```

![image-20230628201108475](%E6%95%B4%E7%90%86.assets/image-20230628201108475.png)



 slot-scope="scope"

v-slot缩写成#

作用域插槽

games数据在Category（子）组件中，但使用数据所遍历出来的结构由App（父）组件决定）

插槽有点混，

<slot name=''>   ==    <template v-slot:' '>

按照插槽类型来那个叫operate



绑定在 `<slot>` 元素上的 attribute 被称为**插槽 prop**。现在在父级作用域中，我们可以使用带值的 `slot-scope` 来定义我们提供的插槽 prop 的名字：

 







#### 

```
  <template #operate="{scope}">
```

还是不知道这个到底是传的啥，{scope}代表什么

我理解好像还是有点偏差，作用域插槽是可以和具体插槽一起用吗

带{}就是吧它当js处理吧，但是我怎么没有看到scope方法？

上面的都是错误的理解

描述：作用域插槽其实就是带数据的插槽，即带参数的插槽（所以你能具名后，后面有参数的写法了吧   <template v-slot:header="scope">），简单的来说就是子组件提供给父组件的参数，该参数仅限于插槽中使用，父组件可根据子组件传过来的插槽数据来进行不同的方式展现和填充插槽内

```
   <template #operate="{scope}">
          <el-button @click.native.stop="handleAudit(scope.row)" type="text">审核</el-button>
        </template>
```





v-slot
在vue2.6中。上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
子组件用法保持不变，父组件中
slot属性弃用，具名插槽通过指令参数v-slot:插槽名的形式传入，可以简化为#插槽名
slot-scope属性弃用，作用域插槽通过v-slot:xxx="slotProps"的slotProps来获取子组件传出的属性
v-slot属性只能在template上使用，但在只有默认插槽时可以在组件标签上使用
————————————————
版权声明：本文为CSDN博主「别来打扰我」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_44166697/article/details/108274625
————————————————



```
    <!--  slot-scope 作用域插槽中的父组件使用数据 -->
        <!--子部件这个部分的数据传过来了  <slot v-else-if="col.slotName" :name="col.slotName" :scope="scope" /> -->
          <span v-if="item.slotName" :slot="item.slotName" slot-scope="{ scope }">
            <!-- 然后又把它传出去了，传了个name和scope -->
            <slot :name="item.slotName" :scope="scope"></slot>
          </span>
```

传到这了：

```
<template #operate="{scope}">
          <el-button @click.native.stop="handleAudit(scope.row)" type="text">审核</el-button>
        </template>
```

然后传到里面默认插槽里

也就是这里

```
  <slot :name="item.slotName" :scope="scope"></slot>
```

逻辑好怪，传数据进子组件里，用作用域插槽把子组件里的数据又取出来了，然后又用默认插槽放到子组件里去



 <template #operate="{scope}">



这里又用的新写法，其他地方用的老写法



## $set、$forceUpdate() 

[vue强制更新视图 $forceUpdate() - 掘金 (juejin.cn)](https://juejin.cn/post/6973830848529301534)





## @Provide()、@Inject()依赖注入

[依赖注入 | Vue.js (vuejs.org)](https://cn.vuejs.org/guide/components/provide-inject.html#inject)

实现祖与后代通信

projectDetailPage：

```js
export default class projectDetailPage extends Vue {

 @Provide() OPHandle: projectDetailPage = this
```

TreeFile2

```js
export default class TreeFile2 extends Vue {
  @Inject() OPHandle!: Handle | any
```

##### `props`和`$ref`和`$children`和`provide/inject`的主要区别：

- props 侧重于数据的传递，并不能获取子组件里的属性和方法，适用于自定义内容的使用场景
- $ref 侧重于获取子组件里的属性和方法，并不是太适合传递数据，并且 ref 常用于获取dom元素，起到选择器的作用
- $children 侧重于获取所有的直接子组件，得到的是一个无序的数组，并不太适合向多个子组件传递数据
- provide/inject 侧重于在开发高阶插件/组件库时使用，并不推荐用于普通应用程序代码中



- provide 和 inject的绑定并**不是可响应**的，这是刻意为之的。但是，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的；

- 如果你想要共享的这个属性是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像`Vuex`这样真正的状态管理方案了。

  耦合起来了，重构困难，所以一般是用在高级插件开发中咯

  [Vue组件之间的传值 - 掘金 (juejin.cn)](https://juejin.cn/post/6904536680183791623#heading-10)













## 生命周期

created 	组件再内存中创建完毕后 	发ajax请求初始数据



mounted  	 虚拟Dom已经被挂载到真实Dom上，此时我们可以获取Dom节点，`$ref`在此时也是可以访问的。

> 我们在此时可以去获取节点信息，做Ajax请求，对节点做一些操作



**vue异步请求适合放在created里面，如涉及到需要页面加载完成之后的操作就放在mounted里面**





在initState()做了这些事情：

if (opts.props) initProps(vm, opts.props)//初始化Props
if (opts.methods) initMethods(vm, opts.methods)//初始化methods
if (opts.data) {
  initData(vm)} else {
  observe(vm._data = {}, true /* asRootData */)}//初始化data
if (opts.computed) initComputed(vm, opts.computed)//初始化computed

4.所以Props，methods,data和computed的初始化都是在beforeCreated和created之间完成的。



## 体会	:class 和:style的区别

Class 与 Style 绑定 | Vue.js (vuejs.org)



之前有点区分不开：class的对象使用（现在还是不明白，怎么有些用了‘ ’，有些没用）



我们可以给 :class 绑定一个数组来渲染多个 CSS class：



data() {

  return {

​    activeClass: 'active',

​    errorClass: 'text-danger'

  }

}

template



<div :class="[activeClass, errorClass]"></div>

:style 支持绑定 JavaScript 对象值，对应的是 HTML 元素的 style 属性：



data() {

  return {

​    activeColor: 'red',

​    fontSize: 30

  }

}

template



## 过滤器

- 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}}
- 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = “xxx | 过滤器名”

单斜杠 |









# axios

**那个导出的配置项，写的特别好特别全，如果搞透了，我考，面试axios二次封装随便问**

axios的使用和二次封装的一些实例，请求配置、默认配置项、自定义配置项

const request = axios.create({ timeout: 60000 })

开始写自定义配置项

自定义配置，写个request ，export 出来

统一放到一个地方管理

```js
import {request} from "@/utils/request";
import {cookies} from "@/utils/cookies";
```



```js
// 上面两个类已经排查完了，先在这个文件中声明，方便后面的使用
export {request, cookies}

```

在外面引入 request方法后直接 return用

```js
export const getExport = (url: string, params: Object, fileName = '') => {
 return request({
  url: url,
  params: params,
  method: 'get',
  responseType: 'blob',
  baseURL: baseUrl
 }).then((res: any) => {
```



文件预览中

```js
  // 申报材料
 async initDeclareTreeData() {
	const { data }: any = await fetch.get('/xiangmu/prj/box/declareTree', {
      projectCode: this.subParams.projectCode
    })
```

fetch.ts中封装的get方法

```js
export const get = (url: string, params: Object) => {
  return request({
    url: url,
    params: params,
    method: 'get',
    baseURL: baseUrl
  })
}
```





- [ ] Request.ts的导出请求

可以结合项目看，重点请求拦截和响应拦截，检测权限（是否登录）

- [ ] fetch.ts 


```js
export const getExport = (url: string, params: Object, fileName = '') => {
  return request({
    url: url,
    params: params,
    method: 'get',
    responseType: 'blob',
    baseURL: baseUrl
  }).then((res: any) => {
  //主要是这一块
    const blob = new Blob([res.data], {type: res.headers['content-type']})
    const link = document.createElement('a')
    link.href = window.URL.createObjectURL(blob)
    link.download = fileName ? fileName + '.xlsx' : decodeURI(res.headers['content-disposition'].split('=')[1])
    link.click()
    window.URL.revokeObjectURL(link.href)
    
  })
}
```





有封装拦截器联想到权限管理，这些就属于接口权限

路由守卫就是路由权限



还有菜单权限、按钮权限



[TypeScript实战之用TS封装Axios - 掘金 (juejin.cn)](https://juejin.cn/post/7113475007598034951?searchId=202308111708457DF3B53886CEC20788F3)

# vue-router

### `$route`和`$router`的区别

> - $route是“路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
> - $router是“路由实例”对象包括了路由的跳转方法，钩子函数等。

##### Vue-router的封装思想和使用:

- 全在App_main.ts里（入口文件而已）

routerMain在这里引入和app里使用，使得// routerMain 相当于 this.$router  路由对象

从这里看进routerMain的index：

路由对象在这new、导出；汇总在这引入写的其他小模块的路由文件

```
const routerMain = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes: routeAll
})

export { routeAll, routeName2PathMap, routerMain }
export default routerMain

```



- 路由传参

- 路由守卫：src\router\filter\routerFilter.ts    记录下常规用法，在这里对我说，我想在vue中这里，该怎么做

  `routerMain.beforeEach(async (to: Route, _: Route, nextStep: any) => {`

   `console.log(to.path,'to.path====>>>>>')`

   `if(to.path.startsWith('/sub/subSystem-xyna') ){`

    `document.title = '长沙市信用农安智慧监管平台'`

   `}`

   `if(to.path.startsWith('/sub/subSystem-cloud') ){`

    `document.title = '智慧农业农村云上资料库'`

   `}`





## query和params传参的区别

<details open=""> <summary>参考答案</summary>
<ul>
<li><strong>query传递参数</strong>
<code>query</code>传递参数不会出现参数丢失的情况，不需要做其他配置，缺点就是参数会拼接到url后面：url?xx==yy这种方式来传递，会暴露参数，并且url也有字符长度的限制。</li>
</ul>
<p>使用方式: <code>this.$router.push({path: 'path', query: {id:1}})</code><br>
获取参数: <code>this.$route.query.id</code>获取key为id的路由参数</p>
<ul>
<li><strong>params传递参数</strong>
params传递参数是将参数放在<code>route</code>对象中，没有放在url后面，但是在跳转之后的页面刷新时，会导致当前路由中保存的params的参数丢失。</li>
</ul>
<p>使用方式：<code>this.$router.push({name: 'name', params:{id:1}})</code><br>
获取参数: <code>this.$route.params.id</code>&nbsp;获取route对象中的Params的参数信息</p></details>




链接：https://juejin.cn/post/6998324288465928205


## 路由守卫



# Vuex

**页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。 mutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中 通过mapGetter来动态获取state中的值**



# E-charts

# Element-UI

样式穿透::v-deep



### el-row

  <!--<el-row是布局  :gutter="20" 分栏间隔 -->



### el-form

```
      <el-form
          :model="form"
          :rules="rules"
          label-position="top"
          ref="FormRef"
          label-width="100px"
          class="dynamic-form"
        >
```



Form 组件提供了表单验证的功能，只需要通过 `rules` 属性传入约定的验证规则，并将 Form-Item 的 `prop` 属性设置为需校验的字段名即可。(**prop值需要和绑定的值同名！！！**不要再犯错误了)

```
 private rules = {
    title: [{ required: true, message: '请输入', trigger: 'blur' }],
    tagIds: [{ required: true, message: '请选择', trigger: 'change' }]
  }
```

[(185条消息) Element表单验证rules整理_element rules有哪些属性_pany_k的博客-CSDN博客](https://blog.csdn.net/weixin_49431999/article/details/109721425)





 label-position="left" 触发要给每个label赋长度，因为不这样的话每个label的width是100%



label-width="100px"





### descriptions描述列表

div slot="title" class="dialog-title  -------------描述列表自带的插槽，还有footer插槽，默认是显示的，在这把它设没了，学会使用

主要参数:span

```
<div v-if="item.boolean">
            {{ dialogData[item.value] ? '是' : '否' }}
          </div>
          <div v-else-if="item.aaa">
            123
          </div>
          <div v-else>
            {{ dialogData[item.value] || '--' }}
          </div>
```



b)  tooltip

c)  upload

d)  table

e）骨架屏

### dialog弹窗

##### [](https://element.eleme.cn/#/zh-CN/component/dialog#slot)Slot

| name   | 说明                    |
| :----- | :---------------------- |
| —      | Dialog 的内容           |
| title  | Dialog 标题区的内容     |
| footer | Dialog 按钮操作区的内容 |

```
<div slot="title" class="dialog-title">
```





### el-upload

自定义上传方法 :http-request="handleUpload"		

handleUpload (params: any) 	的params怎么来的

传进来的参只能叫params（因为是重写el-upload自带的方法缘故吧），params内容：

action、data、file



**运用在项目中文件上传页面**

​	:on-success="handleSuccess"						on-success	文件上传成功时的钩子



​    :http-request="handleUpload"					覆盖默认的上传行为，可以自定义上传的实现（用了:auto那啥的这个会失效）



​	multiple 

 是否支持多选文件   boolean	





### Tree 树形控件

[组件 | Element](http://10.14.2.33:12456/#/zh-CN/component/tree#scoped-slot)

 default-expand-all  是否默认展开所有节点   默认false

 :indent="20"  相邻级节点间的水平缩进，单位为像素 	默认16

 slot-scope="{ node, data }"  自定义树节点的内容，参数为 { node, data }

 @node-drag-start="handleDragStart"， @node-drop="handleDrop"

拖拽开始、拖拽完成

  :allow-drop="allowDrop"  拖拽位置的判断



### el-progress

```js
     <el-progress
            :width="200"
            :format="progressFormat"
            type="circle"
            :percentage="windowParams.loadingPercent"
          ></el-progress>
```



### Cascader 级联选择器





### el-select

```vue
   <el-select
                  v-model="formData.meetUnitId"
                  placeholder="请选择"
                  :disabled="idDetail"
                  :popper-append-to-body="false"
                  @change="handleUnitChange"
                  visible-change="requestMeetingPlace"
                >
                  <el-option v-for="item in unitList" :key="item.unitId" :label="item.unitName" :value="item.unitId">
                  </el-option>
                </el-select>
```



开启搜索：filterable



搜索的条件下将创建新的条目加入选择栏：

`allow-create`属性即可通过在输入框中输入文字来创建新的条目。注意此时`filterable`必须为真

 default-first-option： 按回车选中匹配项



封装一下还能将创建的条目添加进下拉选项





#### el-option

显示在页面的是绑定的：label，v-model选中的值是：value



# 其他积累

### 编程技巧

clg

快速打印





### lodash库	[**Lodash 中文文档**](https://www.lodashjs.com/)

对象，数组操作的语法库，深拷贝，防抖，节流

#### lodash节流使用

搜索栏的联想词的出现

```js
 onWindowMessage (message: any) {
    // 创建一个节流函数，在 wait 秒内最多执行 func 一次的函数
    throttle(() => {
      if (message.data.keyDigNumGather) {
        if (message.data?.keyDigNumGather === this.subParams.keyDigNumGather) {
          this.$emit('refreshInit')
        } else if (message.data?.keyDigNumGather === this.treeData.keyDigNumGather) {
          this.$emit('refreshInit')
        }
      }
    }, 500)()
  }
```





### 





### contextMenu

[Element: contextmenu event - Web API 接口参考 | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/contextmenu_event)

**`contextmenu`** 事件会在用户尝试打开上下文菜单时被触发

[vue3+ts开发vue3-context-menu插件 - 掘金 (juejin.cn)](https://juejin.cn/post/6974596228914872350?searchId=202307191727067A339FB81AB9CD657070)

### websocket

[一文吃透 WebSocket 原理 刚面试完，趁热赶紧整理 - 掘金 (juejin.cn)](https://juejin.cn/post/7020964728386093093)





### wangeditor

富文本编辑器的使用 wangeditor for vue



### [Jenkins详细教程 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/157592663)





### qs库

axios的 get 方法 params 传参，在输入框中输入某些特殊字符 例如中括号、Json格式参数等，请求时会直接报 400 错误，Bad Request

方案：在创建 axios 实例时，增加可选的[序列化](https://so.csdn.net/so/search?q=序列化&spm=1001.2101.3001.7020)属性 paramsSerializer，按需求使用encodeURIComponent、JSON.stringifyt等方法处理参数，在负责序列化 'params’的函数中使用自定义参数的序列化



[axios请求传参自定义paramsSerializer序列化_axios paramsserializer_码大星的博客-CSDN博客](https://blog.csdn.net/hututu3/article/details/123222938)

### 插件

GitLens — Git supercharged

Git History



[第 1 章: 我们在做什么？ · 函数式编程指北 (gitbooks.io)](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html)

## Git

[Learn Git Branching](https://learngitbranching.js.org/?locale=zh_CN)

### 在项目里的运用



#### git操作：提交到master

先保存到暂存区 git stash		等下要拉代码的，别把自己代码冲点

然后拉取master 最新代码	git pull origin master	(应该是看有没有新代码提交上去的)

再把自己代码拿出来  		git stash pop



转入github desktop   进行add commit  push 操作



提交 feat  fix





```js
1、git stash

    备份当前工作区的内容，保存到git 栈中，从最近的一次commit中读取相关内容

2、git pull  或者做其他的工作    

3、git stash pop

    从git栈中获取到最近一次stash进去的内容，恢复工作区的内容。。获取之后，会删除栈中对应的stash。。

    由于可能会stash多次，git使用栈管理，我们可以使用git stash list查看所有的stash
 4. git stash clear

        清空git栈

还可以git reset --hard放弃本地修改，然后就可以git pull了。。但是不推荐使用gitreset --hard指令，实在是太危险啦！
```

#### 分支

![image-20230629192719908](%E6%95%B4%E7%90%86.assets/image-20230629192719908.png)

git checkout 

git merge （要合并到）   合并

`git pull` 就是 fetch 和 merge 的简写

`git pull --rebase` 就是 fetch 和 rebase 的简写！

git rebase （x分支）   合并分支的方法--把当前分支复制到x分支上。

Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。**拉公共分支最新代码**

git pull -r或git pull --rebase

（好像只有个人开发用？）

![img](%E6%95%B4%E7%90%86.assets/f0729d5bc6504c2283ecff9fdb3e484a.png)



------

git config --list

git credential-manager uninstall

 

------

源代码管理，中

+号（暂存更改）  代表是git add   

------

**git push <remote> <place>**

命令后的origin 参数 代表远程仓库

```
git push origin main
```

把这个命令翻译过来就是：

*切到本地仓库中的“main”分支，获取所有的提交，再到远程仓库“origin”中找到“main”分支，将远程仓库中没有的提交记录都添加上去，搞定之后告诉我。*

我们通过“place”参数来告诉 Git 提交记录来自于 main, 要推送到远程仓库中的 main。它实际就是要同步的两个仓库的位置。

要同时为源和目的地指定 `<place>` 的话，只需要用冒号 `:` 将二者连起来就可以了

1. `<remote>`：远程仓库的名称。它指定了你要将代码推送到哪个远程仓库。例如，`origin` 是默认的远程仓库名称。
2. `<branch>`：分支的名称。它指定了你要推送哪个分支的代码。例如，`master` 是默认的主分支名称。
3. `--all`：推送所有分支到远程仓库。使用这个参数可以将本地所有分支都推送到远程仓库。
4. `--tags`：推送所有标签到远程仓库。使用这个参数可以将本地所有标签都推送到远程仓库。
5. `--force`：强制推送。使用这个参数可以强制将代码推送到远程仓库，即使有冲突或者会覆盖已有的提交。
6. `--set-upstream` 或 `-u`：设置上游分支。使用这个参数可以将当前分支与远程分支关联起来，以后可以直接使用 `git push` 推送代码。
7. `<refspec>`：自定义引用规范。它可以指定要推送的分支或标签的引用规范。例如，`refs/heads/feature`



------



##### 学习内容

查看log

![image-20230629191624781](%E6%95%B4%E7%90%86.assets/image-20230629191624781.png)







## Token

token的两种方案：

- 将 token 放在 cookie 里；
- 将 token 放在请求头里，用 Authorization 字段

**认证步骤解析**

1. 客户端发送登录请求
2. 服务端校验账号密码，生成 Token，并返回给客户端
3. 收到 Token 以后需要把它存储起来，web 端一般会放在 localStorage 或 Cookie 中
4. 客户端请求 API 资源的时候，将 Token 通过 HTTP 请求头 Authorization 字段或者其它方式发送给服务端
5. 服务端拿到 Token，做解密和签名校验，通过校验返回数据，否则返回 401



感觉没有找到自己想要看的东西





# TODO



浏览器输入url到页面加载全过程