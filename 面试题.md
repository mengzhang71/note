# CSS

## margin

#### 负值问题

![image-20230831154016057](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230831154016057.png)

绿色的设margin-bottom负值和黄色的设margin-top负值效果好像是一样的

left，right也是一样



#### 重叠问题

[中高级前端面试题总结第一期_前端面试题中高级_前端.火鸡的博客-CSDN博客](https://clearlove.blog.csdn.net/article/details/126422837?spm=1001.2014.3001.5502)

margin重叠值得是上下两个div，当给上面的div设置marginBottom，同时给下面的div设置marginTop的时候，他们的距离只会按照较大的那个进行设置，而不是相加的和，这个现象就叫做margin重叠

#### 塌陷问题

BFC，去看git的css

# JS

## JavaScript有多少种数据类型?

**八种**，分别为 ：

- **Number**
- **String**
- **Boolean**
- **undefined**
- **null**
- **Object**
- **Bigint**
- **Symbol**



# ES6

## var let const

let   不存在变量提升，存在暂时性死区，块级作用域，同一作用域不允许重复声明

- 变量提升
- 暂时性死区      只有等到声明变量的那一行代码出现，才可以获取和使用该变量

var name = '青莲使者'

 {    **me = 'li'**    let me }



感觉两者像因果关系，因为不存在变量提升问题，所以会被暂时性锁区

- 块级作用域    var不存在
- 重复声明    只有var允许





提const，就说比let更严格，它有let所有的特性，并且不能修改声明的变量

最后说使用的场景说明：let一般应用于基本数据类型；const 一般应用于引用数据类型，也就是函数对象等。

- 修改声明的变量    

从let讲起  let加了这些规范，var全没有



## 手搓Promise

1、Promise 本身相当于一个状态机，拥有三种状态：
pending(等待态)
fulfiled(成功态)
rejected(失败态)
一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。
2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return 的结果作为该 Promise resolve 的结果，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的参数为两个函数，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。







promise思想：

执行到了resolve，Promise的状态就会从pedding变为fulfilled，状态一旦改变就不会再更改了

romise中有`throw`的话，就相当于执行了`reject`



then是Promise上的方法，当Promise状态为`fulfilled`执行`成功回调`，为`rejected`执行`失败回调`，

如resolve或reject在定时器里，则定时器结束后再执行then	

​		实现：在then方法判断状态，是成功就调用`成功回调`，是失败就执行`失败回调`，

是pedding就把两个回调存起来（如onRejectedCallbacks），然后再触发resolve时，存的那个变量就有长度了（onRejectedCallbacks.length），就会去调用

```js
let p1 = new Promise((resolve, reject) => {
    resolve('成功')
    reject('失败')
})
console.log('p1', p1)

let p2 = new Promise((resolve, reject) => {
    reject('失败')
    resolve('成功')
})
console.log('p2', p2)

let p3 = new Promise((resolve, reject) => {
    throw('报错')
})
console.log('p3', p3)


```

[看了就会，手写Promise原理，最通俗易懂的版本！！！ - 掘金 (juejin.cn)](https://juejin.cn/post/6994594642280857630#heading-1)



# Vue

## 用index做key有什么问题

在进行 `diff` 算法时，会认为同一个 `index` 的组件或元素是同一个

使用 `index` 作为 `key` 和没写基本上没区别，因为不管数组的顺序怎么颠倒，`index` 都是` 0, 1, 2...` 这样排列，导致 `Vue` 会复用错误的旧子节点，做很多额外的工作。



