# CSS

## margin

#### 负值问题

![image-20230831154016057](%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20230831154016057.png)

绿色的设margin-bottom负值和黄色的设margin-top负值效果好像是一样的

left，right也是一样



#### 重叠问题

[中高级前端面试题总结第一期_前端面试题中高级_前端.火鸡的博客-CSDN博客](https://clearlove.blog.csdn.net/article/details/126422837?spm=1001.2014.3001.5502)

margin重叠值得是上下两个div，当给上面的div设置marginBottom，同时给下面的div设置marginTop的时候，他们的距离只会按照较大的那个进行设置，而不是相加的和，这个现象就叫做margin重叠

#### 塌陷问题

BFC，去看git的css





## rem r

rem r代表着root，可以用来做web app屏幕适配

一个是相对根元素，一个相对父元素

浏览器默认字体大小是16px,1rem就是16px

[rem和em的区别_枫叶在飘呀的博客-CSDN博客](https://blog.csdn.net/ld16631069828/article/details/119078593)



## flex

从flex属性的默认值出发，其实就可以找到flex能够布局自适应的原因

#### flex-grow

上面讲到当容器设为`flex-wrap: nowrap;`不换行的时候

定义项目的放大比例

默认为`0`，即如果存在剩余空间，也不放大

#### flex-shrink

定义了项目的缩小比例

默认为1，即如果空间不足，该项目将缩小

```
.item {
    flex-shrink: <number>; /* default 1 */
}
```



如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小

如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小

```
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```

- flex: 1 = flex: 1 1 0%
- flex: 2 = flex: 2 1 0%
- flex: auto = flex: 1 1 auto
- flex: none = flex: 0 0 auto，常用于固定尺寸不伸缩



## 布局

### 双栏

float+margin

flex		次给定宽，主宽100



## 重绘、回流

重绘是当节点需要更改外观而不会影响布局的，

比如改变 color 就叫称为重绘

回流是布局或者几何属性需要改变就称为回流

用visiblity代替display:none



# JS

## JavaScript有多少种数据类型?

**八种**，分别为 ：

- **Number**
- **String**
- **Boolean**
- **undefined**
- **null**
- **Object**
- **Symbol**



- **Bigint**



## apply、call、bind

### apply

`apply`接受两个参数，第一个参数是`this`的指向，第二个参数是函数接受的参数，以数组的形式传入

改变`this`指向后原函数会立即执行，且此方法只是临时改变`this`指向一次





## 执行上下文

是 JavaScript 中执行代码的环境。它包含了变量、函数、对象等在运行时需要访问的所有信息。



执行上下文由以下三个组成部分构成：

1. 变量环境（Variable Environment）：存储变量声明，函数声明以及函数的形参。
2. 词法环境（Lexical Environment）：存储变量和函数的实际值。
3. this 值（This Value）：指向当前执行上下文所属的对象。

在代码执行过程中，JavaScript 引擎会根据代码来创建和销毁执行上下文，并将相应的变量和函数添加到执行上下文中。同时，变量和函数的访问也是在执行上下文中进行的，它们的作用域链由执行上下文的词法环境决定。



1. 全局执行上下文（Global Execution Context）：全局环境下的执行上下文，是整个程序的最外层上下文，在页面加载时自动创建。
2. 函数执行上下文（Function Execution Context）：每当一个函数被调用时，会创建一个对应的函数执行上下文。每个函数拥有自己的执行上下文。
3. eval 函数执行上下文（Eval Function Execution Context）：在 eval 函数内部执行的代码的执行上下文



# ES6

## var let const

都是声明变量的关键字



let 

1. 不存在变量提升，
2. 存在暂时性死区，
3. 块级作用域，
4. 同一作用域不允许重复声明

const再多一个，值不能更改

- 变量提升
- 暂时性死区      只有等到声明变量的那一行代码出现，才可以获取和使用该变量

var name = '青莲使者'

 {    **me = 'li'**    let me }



感觉两者像因果关系，因为不存在变量提升问题，所以会被暂时性锁区

- 块级作用域    var不存在
- 重复声明    只有var允许





提const，就说比let更严格，它有let所有的特性，并且不能修改声明的变量

最后说使用的场景说明：let一般应用于基本数据类型；const 一般应用于引用数据类型，也就是函数对象等。

- 修改声明的变量    

从let讲起  let加了这些规范，var全没有



## 手搓Promise

链式回调优化代码体验

比函数回调那种，把函数当参数传，然后在函数里使用，结果连着写一堆的花括号的逻辑会清晰写



1、Promise 本身相当于一个状态机，拥有三种状态：
pending(等待态)
fulfiled(成功态)
rejected(失败态)
一个 Promise 对象初始化时的状态是 pending，调用了 resolve 后会将 Promise 的状态扭转为 fulfilled，调用 reject 后会将 Promise 的状态扭转为 rejected，这两种扭转一旦发生便不能再扭转该 Promise 到其他状态。
2、Promise 对象原型上有一个 then 方法，then 方法会返回一个新的 Promise 对象，并且将回调函数 return 的结果作为该 Promise resolve 的结果，then 方法会在一个 Promise 状态被扭转为 fulfilled 或 rejected 时被调用。then 方法的参数为两个函数，分别为 Promise 对象的状态被扭转为 fulfilled 和 rejected 对应的回调函数。









promise思想：



执行到了resolve，Promise的状态就会从pedding变为fulfilled，状态一旦改变就不会再更改了

不可扭转实现：   **if** (this.PromiseState !== 'pending') **return**



romise中有`throw`的话，就相当于执行了`reject`

实现，catch里写reject

then是Promise上的方法，当Promise状态为`fulfilled`执行`成功回调`，为`rejected`执行`失败回调`，



如resolve或reject在定时器里，则定时器结束后再执行then	

延迟调用,n秒后才执行then函数，但是我们可以保证1秒后再执行then里的回调

如果结束调用then了，用状态处理，if状态还是pendding，就用数组存起来，然后再触发resolve时再调用数组里的函数

```js
 this.onFulfilledCallbacks = [] // 保存成功回调
```





​		实现：在then方法判断状态，是成功就调用`成功回调`，是失败就执行`失败回调`，

（延时调用的方法）是pedding就把两个回调用数组存起来（如onRejectedCallbacks），然后再触发resolve时，存的那个数组就有长度了（onRejectedCallbacks.length），就会去调用里面存的方法

```js
let p1 = new Promise((resolve, reject) => {
    resolve('成功')
    reject('失败')
})
console.log('p1', p1)

let p2 = new Promise((resolve, reject) => {
    reject('失败')
    resolve('成功')
})
console.log('p2', p2)

let p3 = new Promise((resolve, reject) => {
    throw('报错')
})
console.log('p3', p3)


```



链式回调

很简单，让咱们的promise对象返回的是promise对象就行了，就样就能保证继续调用then了呗

实现：在then方法里定义个thenPromise对象了，把上面写的写进来，return这个

[看了就会，手写Promise原理，最通俗易懂的版本！！！ - 掘金 (juejin.cn)](https://juejin.cn/post/6994594642280857630#heading-1)







### 作用域

JS作用域也就是JS识别变量的范围，作用域链也就是JS查找变量的顺序

全局作用域、局部作用域和ES6的块级作用域



#### 作用域链

当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。



### 闭包

能够读取外层函数内部变量的函数



闭包的定义很简单:函数 A返回了一个函数 B，并且函数 B 中使用了函数 A的变量，函数 B 就被称为闭包。



本来执行过程和词法作用域是封闭的，这种返回的函数就好比是一个虫洞，开了挂。

闭包的形成很简单，在执行过程完毕后，返回函数，或者将函数得以保留下来，即形成闭包（我的理解：比如你要实现一个简单的计算器的加法功能，你就写了一个封闭的函数叫add，里面有变量，还有一个函数，那个函数就是实现功能的，你现在return那个函数，然后去调用这个add函数，这就是闭包呀）

总结：

函数内部写另一个函数进行访问该函数内部的成员变量的过程



因为js函数是有封闭的函数作用域的，所以我们在另一个



 这样就可以：....			（引出优缺点）

在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰



坏处呢：

无法销毁



闭包是指函数的能力，可以访问外部作用域变量；

而作用域链是引擎在查找变量时所遵循的路径，指一种机制



还可以讲一下项目开发里的单例模式

# Vue

## 双向绑定原理

**和响应式原理做区分**



vue 实现数据双向绑定主要是: 

采用数据劫持结合发布者-订阅者模式的方式，

**通过Object.defineProperty() 来劫持各个属性的 setter 、getter** ，在数据变动时发布消息给订阅者，触发相应监听回调 。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 object.defineProperty0) 将它们转为 getter/setter 。用户看不到 getter/setter ，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

vue的数据双向绑定将MVVM 作为数据绑定的入口 ，整合 observer，Compile 和watcher 三者，通过 observer 来监听自己的 mode1 的数据变化， 通过 Compile 来解析编译模板指令 ( vue 中是用来解析 {{}}} )， 最终利用 watcher 搭起 observer 和Compile 之间的通信桥梁， 达到数据变化一>视图更新;视图交互变化( input )一>数据 mode1 变更双向绑定效果。



## 用index做key有什么问题

在进行 `diff` 算法时，会认为同一个 `index` 的组件或元素是同一个

使用 `index` 作为 `key` 和没写基本上没区别，因为不管数组的顺序怎么颠倒，`index` 都是` 0, 1, 2...` 这样排列，导致 `Vue` 会复用错误的旧子节点，做很多额外的工作。









### **图片懒加载**

```text
就是在加载页面的时候，如果页面中的图片过多，可以使用占位符的方式替换没有在可是区域内的图片，
只加载当前需要现实的图片。监听滚动条的位置，当图片标签出现在可视区域的时候，重置图片的路径为真是路径，
然后展示图片地址。一般在实际开发的时候都直接使用图片懒加载插件实现。
还有一种解决方案就是使用页面骨架屏效果，也是类似占位显示，当数据加载完成之后替换掉占位显示的内容
```





图片懒加载 v-LazyLoad

[(9 封私信 / 80 条消息) 千锋前端学习营 - 知乎 (zhihu.com)](https://www.zhihu.com/org/qian-feng-html5xue-yuan)





`image.offsetTop <= document.documentElement.clientHeight + document.documentElement.scrollTop` 判断图片是否可以在可视区域内。

[图片懒加载原理方案详解 - 掘金 (juejin.cn)](https://juejin.cn/post/7196970992576397367)



作者：千锋前端学习营
链接：https://zhuanlan.zhihu.com/p/649375930
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。





x + y =144



# Http

## 从输入 url 到展示的过程

DNS 解析
TCP 三次握手
发送请求，分析 ur1 ，设置请求报文(头， 主体)

服务器返回请求的文件( htm1 )

浏览器渲染
		HTML parser --> DOM Tree0
		标记化算法，进行元素状态的标记

​		dom 树构建
Cssparser --> Style Tree

​		解析 css 代码，生成样式树
attachment --> Render Tree
​		结合 dom树与 style树，生成渲染树
layout:布局
GPU painting:像素绘制页面



## UDP与TCP的区别

（只是数据报文的搬运工）

面向不连接	

高效

不可靠



建立断开都要握手

头部字段复杂的多

传输过程通过各种算法保证可靠性		流量控制、拥塞处理



## GET/POST的区别

get放在url里，post放在请求体里，所以post比较安全，

url有长度限制，所以会影响get，而post没有，能带的东西比较多

回退post会有影响





get :缓存、请求长度受限 、会被历史保存记录无副作用(不修改资源)，幂等(请求次数与资源无关)的场景post :安全、大数据、更多编码类型



其实只是语义化的区别







## HTTP 2.0

相比于1就是性能大大提升

多路复用
二进制分帧层: 应用层和传输层之间
首部压缩
服务端推送



284是高配考点

排序在435页



复习在472